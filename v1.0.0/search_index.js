var documenterSearchIndex = {"docs":
[{"location":"AirfoilTools/parameterizations/#Common-Parameterizations","page":"Airfoil Generation","title":"Common Parameterizations","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"Included in the AirfoilTools module are the following common airfoil parameterizations for convenience in generating various airfoil geometries.","category":"page"},{"location":"AirfoilTools/parameterizations/#Parameter-Types","page":"Airfoil Generation","title":"Parameter Types","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"Each of the parameterizations below have associated composite types whose fields are the parameters used in defining the airfoil geometries.  Each of these composite types is defined using the @kwdef macro such that the user does not need to remember the order of the fields, but can simply define the fields as though they were keyword arguments. In general, few of the fields are given defaults with the exception of things like trailing edge gap or z-positions, which are always defaulted to zero. In addition, some parameterization methods have specific values inherent to their methods. These are exposed to the user for convenience, but are also defaulted to the values inherent in the parameterization method.","category":"page"},{"location":"AirfoilTools/parameterizations/#Coordinates","page":"Airfoil Generation","title":"Coordinates","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For all of the parameterizations, the x-coordinates are defined to be along the chord-wise direction, and the z-coordinates are orthogonal to the x-coordinates.  This is done to be similar to the standard airframe coordinate system, with the x-direction being positive toward the back of the airframe, and the z-direction being up.","category":"page"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"In addition all coordinates are given clockwise from the trailing edge, even if the coordinates are split between upper and lower sides.  In other words, the coordinates are given from the lower trailing edge to the leading edge, then the leading edge back to the upper side trailing edge.  In general, if the coordinates are given in an upper and lower split, the leading edge point is repeated.","category":"page"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"","category":"page"},{"location":"AirfoilTools/parameterizations/#NACA-4-series","page":"Airfoil Generation","title":"NACA 4-series","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"We begin with the standard NACA 4-series airfoil, defining the parameters in the NACA4 type as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.NACA4","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.NACA4","text":"NACA4\n\nFields\n\nmax_camber::Float=2.0 : maximum camber in % chord\nmax_camber_pos::Float=4.0 : x-position of maximum camber point in 1/10 chord\nmax_thickness::Float=12.0 : maximum thickness in % chord\nblunt_te::Bool=false : flag for whether to use the blunt trailing edge NACA 4-series definition or not.\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"note: Defaults\nThe NACA4 parameter type is the only one with fully defined defaults, which happen to default to the NACA 2412 airfoil with a sharp trailing edge due to its ubiquity.","category":"page"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A NACA 4-series airfoil can be defined with either of the naca4 methods.","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.naca4","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.naca4","text":"naca4(parameters::NACA4; N=161, x=nothing, split=false)\n\nCompute x, z airfoil coordinates for N nodes, based on NACA 4-Series Parameterization.\n\nArguments\n\nparameters::NACA4 : NACA 4-series parameters\n\nKeyword Arguments\n\nN::Int=161 : Total number of coordinates to use.  This values should be odd, but if not, the number of points returned will be N-1.\nx::AbstractArray{Float} : x coordinates (cosine spaced coordinates used by default)\nsplit::Bool=false : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\nnaca4(c=2.0, p=4.0, t=12.0; N=161, x=nothing, blunt_te=false, split=false)\n\nCompute x, z airfoil coordinates for N nodes, based on NACA 4-Series Parameterization.\n\nArguments\n\nc::Float : Maximum camber value (percent of chord)\np::Float : Position along chord (in 10ths of chord) where maximum naca4_camber lies\nt::Float : Maximum thickness of airfoil in percent chord\n\nKeyword Arguments\n\nN::Int : Total number of coordinates to use.  This values should be odd, but if not, the number of points returned will be N-1.\nx::AbstractArray{Float} : x-coordinates (cosine spaced coordinates used by default)\nblunt_te::Bool : Flag whether trailing edge is blunt or not\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For a given set of x,z coordinates a best-fit NACA 4-series airfoil can be found using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.determine_naca4","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.determine_naca4","text":"determine_naca4(x,z)\n\nCalculate NACA 4-series parameters based on input x,z coordinates.\n\nArguments\n\nx::AbstractArray{Float} : vector of x coordinates for airfoil\nz::AbstractArray{Float} : vector of z coordinates for airfoil\n\nKeyword Arguments\n\nblunt_te::Bool=false : Flag whether trailing edge is blunt or not\n\nReturns\n\nparameters::NACA4 : a parameter object of type NACA4.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/#NACA-65-series","page":"Airfoil Generation","title":"NACA 65-series","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For a given set of x,z coordinates a best-fit regular NACA 65-series airfoil can be found with the standard airfoil convention given from \"NACA Report No 824 Summary of Airfoil Data\" by  Ira H. Abbott, Albert E. Von Doenhoff, and Louis S. Stivers, Jr.  using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.naca65","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.naca65","text":"Assumes x in non-dimensional range [0.0,1.0]\n\nDescription from NACA Research Memorandum L51G31: \"Systematic Two-dimensional Cascade Tests of NACA 65-Series Compressor Blades at Low Speeds:\"\n\nThe 65-series compressor blade family is formed by combining a basic thickness form with cambered mean lines. The basic thickness form used is the NACA 65(216)-010 thickness form with the ordinates increased by 0.0015 times the chordwise stations to provide slightly, increased thickness toward the trailing edge. In the scaled case, it was not derived for 10-percent thickness but was scaled down from the NACA 65,2-016 airfoil. The scaling procedure gives the best results whep it is restricted to maximum thickness changes of a few percent. The NACA 65-010 basic thickness has also been derived. These thickness forms differ slightly but are considered to be interchangeable.\n\nThe basic mean line used is the a=1.0 mean line. The amount of camber is for the design lift coefficient for the isolated airfoil with clo of 1.0. Both ordinates and slopes are scaled directly to obtain other cambers. Cambered blade sections are obtained by applying the thickness perpendicular to the mean line at stations laid out along the chord line. In the designation the camber is given by the first number after the dash in tenths of clo. For example, the NACA 65-810 and NACA 65-(12)10 blade sections are cambered for clo = 0.8 and clo = 1.2, respectively.\n\nArguments\n\nclo::TF : Design lift coefficient in tenths of chord. Usually first number after the 2nd dash (ie NACA 65-3-818 would input 0.8 for clo)\na::TF : Mean-line designation, fraction of chord from leading edge over which design load is uniform.\nseries_number::String : digits of the airfoil series family with clo of 0 (ie NACA 65-3-818 would be \"3-010\")\n\nKeyword Arguments\n\nx::Vector{TF} = nothing : input x values if specificing x values manually\nsplit::Boolean = false : if true, then the output will be split between top and bottom coordinates\nextra_blending::Boolean = false : If desired number of points is large (> 300ish) then set to true and it will add some extra blending if desired. Note: This is generally not needed!\n\nouptuts\n\nx::Vector{TF} : x coordinates\ny::Vector{TF} : y coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"using FLOWFoil\n\n#define design lift coefficient\nclo = 1.0\n\n#define mean line designation\na = 1.0\n\n#define series number\nseries_number = \"3-018\"\n\nx,y = AirfoilTools.naca65(clo, a, series_number)","category":"page"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"There exists a special scaled case for the NACA 65-010 family of airfoils. This special case only requires the user to input a design lift coefficient. using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.naca65_scaled","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.naca65_scaled","text":"Assumes x in non-dimensional range [0.0,1.0]\n\nDescription from NACA Research Memorandum L51G31: \"Systematic Two-dimensional Cascade Tests of NACA 65-Series Compressor Blades at Low Speeds:\"\n\nThe 65-series compressor blade family is formed by combining a basic thickness form with cambered mean lines. The basic thickness form used is the NACA 65(216)-010 thickness form with the ordinates increased by 0.0015 times the chordwise stations to provide slightly, increased thickness toward the trailing edge. In the scaled case, it was not derived for 10-percent thickness but was scaled down from the NACA 65,2-016 airfoil. The scaling procedure gives the best results whep it is restricted to maximum thickness changes of a few percent. The NACA 65-010 basic thickness has also been derived. These thickness forms differ slightly but are considered to be interchangeable.\n\nThe basic mean line used is the a=1.0 mean line. The amount of camber is for the design lift coefficient for the isolated airfoil with clo of 1.0. Both ordinates and slopes are scaled directly to obtain other cambers. Cambered blade sections are obtained by applying the thickness perpendicular to the mean line at stations laid out along the chord line. In the designation the camber is given by the first number after the dash in tenths of clo. For example, the NACA 65-810 and NACA 65-(12)10 blade sections are cambered for clo = 0.8 and clo = 1.2, respectively.\n\nThis specific function plots the NACA 65-010 series which uses special mean line and thickness form coordinates. It scales those coordinates based on the cl_o value.\n\nArguments\n\nclo::TF : Design lift coefficient in tenths of chord. Usually first number after the 2nd dash (ie NACA 65-3-818 would input 0.8 for clo)\n\nKeyword Arguments\n\nx::Vector{TF} = nothing : input x values if specificing x values manually\nsplit::Boolean = false : if true, then the output will be split between top and bottom coordinates\nextra_blending::Boolean = false : If desired number of points is large (> 300ish) then set to true and it will add some extra blending if desired. Note: This is generally not needed!\n\nouptuts\n\nx::Vector{TF} : x coordinates\ny::Vector{TF} : y coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"using FLOWFoil\n\n#define design lift coefficient\nclo = 1.0\n\nx,y = AirfoilTools.naca65_scaled(clo)","category":"page"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"","category":"page"},{"location":"AirfoilTools/parameterizations/#Conformal-Mapping","page":"Airfoil Generation","title":"Conformal Mapping","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"AirfoilTools includes two conformal mapping methods; the first is the Joukowsky method, and the second is the KarmanTrefftz method (which is a variation on Joukowsky allowing for non-cusped trailing edges)","category":"page"},{"location":"AirfoilTools/parameterizations/#Joukowsky","page":"Airfoil Generation","title":"Joukowsky","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"The Joukowsky parameter type is defined as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.Joukowsky","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.Joukowsky","text":"Joukowsky\n\nFields\n\ncenter::AbstractArray{Float} : [x z] location of center of circle relative to origin\nradius::Float : radius of circle\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A Joukowsky airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.joukowsky","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.joukowsky","text":"joukowsky(parameters::Joukowsky; N=361, fortest=false, normalize=true, split=false)\n\nJoukowsky airfoil parameterization.\n\nArguments\n\nparameters::Joukowsky : Joukowsky parameters\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\nfortest::Bool=false : Flag to output non-coordinate paramters used in 'joukowsky_flow()'\nnormalize::Bool=true : Flag whether to normalize to unit chord and translate the leading edge to zero.\nsplit::Bool=false : Flag wheter to split output into upper and lower surfaces.\n\nReturns\n\nIF split == False\n\nx::AbstractArray{Float} : Array of x coordinates\nz::AbstractArray{Float} : Array of z coordinates\n\nIF split == True\n\nxu::AbstractArray{Float} : Array of upper half of x coordinates\nxl::AbstractArray{Float} : Array of lower half of x coordinates\nzu::AbstractArray{Float} : Array of upper half of z coordinates\nzl::AbstractArray{Float} : Array of lower half of z coordinates\n\n\n\n\n\njoukowsky(center, radius; N=361, fortest=false, normalize=true, split=false)\n\nJoukowsky airfoil parameterization.\n\nArguments\n\ncenter::AbstractArray{Float} : [x z] location of center of circle relative to origin\nradius::Float : radius of circle\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\nfortest::Bool=false : Flag to output non-coordinate paramters used in 'joukowsky_flow()'\nnormalize::Bool=true : Flag whether to normalize to unit chord and translate the leading edge to zero.\nsplit::Bool=false : Flag wheter to split output into upper and lower surfaces.\n\nReturns\n\nIF split == False\n\nx::AbstractArray{Float} : Array of x coordinates\nz::AbstractArray{Float} : Array of z coordinates\n\nIF split == True\n\nxu::AbstractArray{Float} : Array of upper half of x coordinates\nxl::AbstractArray{Float} : Array of lower half of x coordinates\nzu::AbstractArray{Float} : Array of upper half of z coordinates\nzl::AbstractArray{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/#Karman-Trefftz","page":"Airfoil Generation","title":"Karman-Trefftz","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"The KarmanTrefftz parameter type is defined as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.KarmanTrefftz","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.KarmanTrefftz","text":"KarmanTrefftz\n\nFields\n\nbeta::Float : angle, in radians indicating center of circle relative to origin\nradius::Float : radius of circle\nwedge_angle::Float : angle, in radians, of airfoil wedge angle\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.KarmanTrefftz-Tuple{Any, Any}","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.KarmanTrefftz","text":"KarmanTrefftz(center, wedge_angle)\n\nArguments\n\ncenter::AbstractArray{Float} : [x z] location of circle center relative to origin\nwedge_angle::Float : angle, in radians, of airfoil wedge angle\n\nReturns\n\nparameters::KarmanTrefftz : KarmanTrefftz parameters\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A Karman-Trefftz airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.karman_trefftz","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.karman_trefftz","text":"karman_trefftz(paramters::KarmanTrefftz; N=361, normalize=true, split=false)\n\nKarman-Trefftz airfoil parameterization based on angle beta, raidus, and wedge angle.\n\nArguments\n\nparamters::KarmanTrefftz : KarmanTrefftz parameters\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\nnormalize::Bool=true : Flag whether to normalize output to unit chord and shift to have leading edge at zero.\nsplit::Bool=false : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\nkarman_trefftz(beta, radius, wedge_angle; N=361, normalize=true, split=false)\n\nKarman-Trefftz airfoil parameterization based on angle beta, raidus, and wedge angle.\n\nArguments\n\nbeta::Float : angle, in radians indicating center of circle relative to origin\nradius::Float : radius of circle\nwedge_angle::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\nnormalize::Bool=true : Flag whether to normalize output to unit chord and shift to have leading edge at zero.\nsplit::Bool=false : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\nkarman_trefftz(center, wedge_angle; N=361, normalize=true, split=false)\n\nIdentical to karman_trefftz(beta, radius, wedge_angle) but using center-based version.\n\nArguments\n\ncenter::AbstractArray{Float} : [x z] location of circle center relative to origin\nwedge_angle::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\nnormalize::Bool=true : Flag whether to normalize out put to unit chord and shift to have leading edge at zero.\nsplit::Bool=false : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIF split == False\n\nx::AbstractArray{Float} : Array of x coordinates\nz::AbstractArray{Float} : Array of z coordinates\n\nIF split == True\n\nxu::AbstractArray{Float} : Array of upper half of x coordinates\nxl::AbstractArray{Float} : Array of lower half of x coordinates\nzu::AbstractArray{Float} : Array of upper half of z coordinates\nzl::AbstractArray{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"","category":"page"},{"location":"AirfoilTools/parameterizations/#[C](#)lass-[S](#)hape-[T](#)ransformations-([CST](#))","page":"Airfoil Generation","title":"Class Shape Transformations (CST)","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"The CST parameter type is defined as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.CST","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.CST","text":"CST\n\nFields\n\nupper_coefficients::AbstractArray{Float} : Vector of coefficients defining the upper side.\nlower_coefficients::AbstractArray{Float} : Vector of coefficients defining the lower side.\ntrailing_edge_zu::Float=0.0 : z-position of the upper side trailing edge.\ntrailing_edge_zl::Float=0.0 : z-position of the lower side trailing edge.\nN1::Float=0.5 : inherent parameter for round-nosed airfoils.\nN2::Float=1.0 : inherent parameter for sharp trailing edge (with optional blunt trailing edge) airfoils.\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A CST airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.cst","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.cst","text":"cst(\n    parameters::CST;\n    N::Integer=80,\n    x=split_cosine_spacing(N),\n    split=false,\n)\n\nObtain airfoil coordiantes (clockwise from trailing edge) from the class shape transformation (CST) parameterization.\n\nArguments\n\nparameters::CST : CST parameters for airfoil.\n\nKeyword Arguments\n\nN::Integer=80 : number of points to use for each side\nx::AbstractArray{Float}=split_cosine_spacing(N) : x-coordinates to use.\ntrailing_edge_zu::Float=0.0 : upper side trailing edge gap\ntrailing_edge_zl::Float=0.0 : lower side trailing edge gap\nN1::Float=0.5 : Class shape parameter 1\nN2::Float=1.0 : Class shape parameter 2\nsplit::Bool=false : if true, returns upper and lower coordinates separately as xl, xu, zl, zu rather than just x, z.\n\nReturns\n\nIf split == false\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\ncst(\n    upper_coefficients,\n    lower_coefficients;\n    N::Integer=80,\n    x=split_cosine_spacing(N),\n    trailing_edge_zu=0.0,\n    trailing_edge_zl=0.0,\n    N1=0.5,\n    N2=1.0,\n    split=false,\n)\n\nObtain airfoil coordiantes (clockwise from trailing edge) from the class shape transformation (CST) parameterization.\n\nArguments\n\nupper_coefficients::AbstractArray{Float} : Vector of CST coefficients for upper side of airfoil.\nlower_coefficients::AbstractArray{Float} : Vector of CST coefficients for lower side of airfoil.\n\nKeyword Arguments\n\nN::Integer=80 : number of points to use for each side\nx::AbstractArray{Float}=split_cosine_spacing(N) : x-coordinates to use.\ntrailing_edge_zu::Float=0.0 : upper side trailing edge gap\ntrailing_edge_zl::Float=0.0 : lower side trailing edge gap\nN1::Float=0.5 : Class shape parameter 1\nN2::Float=1.0 : Class shape parameter 2\nsplit::Bool=false : if true, returns upper and lower coordinates separately as xl, xu, zl, zu rather than just x, z.\n\nReturns\n\nIf split == false\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For a given set of x,z coordinates a best-fit CST airfoil can be found using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.determine_cst","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.determine_cst","text":"determine_cst(\n    x,\n    z;\n    n_upper_coefficients::Integer=8,\n    n_lower_coefficients::Integer=8,\n    trailing_edge_zu=0.0,\n    trailing_edge_zl=0.0,\n    N1=0.5,\n    N2=1.0,\n)\n\nDetermine best-fit CST parameters using a least squares solve.\n\nArguments\n\nx::AbstractArray{Float} : vector of x-coordinates.\nz::AbstractArray{Float} : vector of z-coordinates.\n\nKeyword Arguments\n\nn_upper_coefficients::Integer=8 : number of upper side coefficients to fit\nn_lower_coefficients::Integer=8 : number of lower side coefficients to fit\ntrailing_edge_zu::Float=0.0 : z coordiante of the trailing edge upper surface\ntrailing_edge_zl::Float=0.0 : z coordinate of the trailing edge lower surface\nN1::Float=0.5 : Class shape parameter 1\nN2::Float=1.0 : Class shape parameter 2\n\nReturns\n\nparamters::CST : CST paramters for airfoil.\n\n\n\n\n\ndetermine_cst(\n    xl,\n    xu,\n    zl,\n    zu;\n    n_upper_coefficients::Integer=8,\n    n_lower_coefficients::Integer=8,\n    N1=0.5,\n    N2=1.0,\n)\n\nDetermine best-fit CST parameters for upper and lower sides of airfoil using a least squares solve.\n\nArguments\n\nxl::AbstractArray{Float} : vector of lower side x-coordinates.\nxu::AbstractArray{Float} : vector of upper side x-coordinates.\nzl::AbstractArray{Float} : vector of lower side z-coordinates.\nzu::AbstractArray{Float} : vector of upper side z-coordinates.\n\nKeyword Arguments\n\nn_upper_coefficients::Integer=8 : number of upper side coefficients to fit\nn_lower_coefficients::Integer=8 : number of lower side coefficients to fit\ntrailing_edge_zu::Float=0.0 : z coordiante of the trailing edge upper surface\ntrailing_edge_zl::Float=0.0 : z coordinate of the trailing edge lower surface\nN1::Float=0.5 : Class shape parameter 1\nN2::Float=1.0 : Class shape parameter 2\n\nReturns\n\nparameters::CST : CST paramters for airfoil.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"","category":"page"},{"location":"AirfoilTools/parameterizations/#Basic-B-Spline","page":"Airfoil Generation","title":"Basic B-Spline","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"The basic B-Spline parameterization comes from \"Universal Airfoil Parametrization Using B-Splines\" by Rajnarayan, Ning, and Mehr. It is a cubic B-Spline parameterization based on leading edge radius, trailing edge camber and wedge angle, and optional trailing edge gap distance.","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.BasicBSpline","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.BasicBSpline","text":"BasicBSpline\n\nFields\n\nleading_edge_radius::Float : leading edge radius\ntrailing_edge_camber_angle::Float : trailing edge camber angle (angle of chordline from horizontal at trailing edge).\nwedge_angle::Float : Wedge angle (angle between upper and lower surfaces at trailing edge).\ntrailing_edge_gap::Float=0.0 : distance between upper and lower surfaces at trailing edge. A value of zero indicates a sharp trailing edge.\nthird_ctrlpt_position::Float=1.0/3.0 : the position of the third control point.  This is an inherent value in the parameterization and if changed, the other parameters will not behave as they are defined here.\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A basic B-Spline airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.basic_bspline","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.basic_bspline","text":"basic_bspline(parameters::BasicBSpline; N=160, split=false, return_nurbs=false)\n\nObtain airfoil coordinates from a B-Spline parameterization method.\n\nArguments\n\nparameters::BasicBSpline : BasicBSpline parameters.\n\nKeyword Arguments\n\nN::Integer=160 : number of points to use when defining the airfoil\nsplit::Bool : flag whether to output upper and lower coordinates separately\nreturn_nurbs::Bool : flag whether to output spline knots and control points as well\n\nReturns\n\nif split=false\n\nx::AbstractArray{Float} : x-coordinates from lower TE clockwise to upper TE\nz::AbstractArray{Float} : z-coordinates from lower TE clockwise to upper TE\n\nif split=true\n\nxu::AbstractArray{Float} : array of x-coordinates for the upper half of the airfoil (LE to TE)\nzu::AbstractArray{Float} : array of z-coordinates for the upper half of the airfoil (LE to TE)\nxl::AbstractArray{Float} : array of x-coordinates for the lower half of the airfoil (LE to TE)\nzl::AbstractArray{Float} : array of z-coordinates for the lower half of the airfoil (LE to TE)\n\nif return_nurbs=true, also return:\n\nNURBSu::NURBS.NURBScurve : upper spline object\nNURBSl::NURBS.NURBScurve : lower spline object\n\n\n\n\n\ngbs(leading_edge_radius, trailing_edge_camber_angle, wedge_angle; perturbations=nothing, trailing_edge_gap=0, degree=3, third_ctrlpt_position=1/3, weights=nothing, split=false, return_nurbs=false)\n\nObtain airfoil coordinates from a B-Spline parameterization method.\n\nArguments\n\nleading_edge_radius::Float : Leading Edge Radius\ntrailing_edge_camber_angle::Float : Trailing Edge Camber Angle (degrees)\nwedge_angle::Float : Wedge Angle (degrees)\n\nKeyword Arguments\n\ntrailing_edge_gap::Float=0 : Trailing Edge Gap\nthird_ctrlpt_position::Float=1/3 : The x postion of the third control point.\nsplit::Bool=false : flag whether to output upper and lower coordinates separately\nreturn_nurbs::Bool=false : flag whether to output spline object\n\nReturns\n\nif split=false\n\nx::AbstractArray{Float} : x-coordinates from lower TE clockwise to upper TE\nz::AbstractArray{Float} : z-coordinates from lower TE clockwise to upper TE\n\nif split=true\n\nxu::AbstractArray{Float} : array of x-coordinates for the upper half of the airfoil (LE to TE)\nzu::AbstractArray{Float} : array of z-coordinates for the upper half of the airfoil (LE to TE)\nxl::AbstractArray{Float} : array of x-coordinates for the lower half of the airfoil (LE to TE)\nzl::AbstractArray{Float} : array of z-coordinates for the lower half of the airfoil (LE to TE)\n\nif return_nurbs=true, also return\n\nNURBSu::NURBS.NURBScurve : upper spline object\nNURBSl::NURBS.NURBScurve : lower spline object\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"","category":"page"},{"location":"AirfoilTools/parameterizations/#[Par](#)ametric-[Sec](#)tion-([PARSEC](#))","page":"Airfoil Generation","title":"Parametric Section (PARSEC)","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/#Standard","page":"Airfoil Generation","title":"Standard","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"The nominal PARSEC parameter type implemented is defined as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.PARSEC","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.PARSEC","text":"PARSEC\n\nFields\n\nleading_edge_radius::Float : leading edge radius\nmaximum_thickness_xu::Float : x-position of maximum thickness for upper side.\nmaximum_thickness_xl::Float : x-position of maximum thickness for lower side.\nmaximum_thickness_zu::Float : value of maximum thickness (from zero) for upper side.\nmaximum_thickness_zl::Float : value of maximum thickness (from zero) for lower side.\ncurvature_u::Float : curvature at point of maximum thickness on upper side.\ncurvature_l::Float : curvature at point of maximum thickness on lower side.\ntrailing_edge_angle::Float : angle from chordline to horizontal at trailing edge.\nboattail_angle::Float : angle from chordline to upper/lower surfaces (half of wedge angle).\ntrailing_edge_gap::Float=0.0 : total gap distance between upper and lower surfaces at treailing edge.\ntrailing_edge_z::Float=0.0 : z-position of midpoint between upper and lower surfaces at trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A PARSEC airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.parsec","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.parsec","text":"parsec(p::PARSEC; N::Integer=80, split=false)\n\nCalculate the x,z airfoil coordinates for both top and bottom surfaces using standard PARSEC Parameterization method.\n\nUse parsec() for modified PARSEC implementation.\n\nArguments\n\np::PARSEC : PARSEC paramters including:\nleading_edge_radius : Leading edge radius\nmaximum_thickness_xu : chordwise position of maximum thickness of upper side\nmaximum_thickness_xl : chordwise position of maximum thickness of lower side\nmaximum_thickness_zu : z-coordinate at maximum thickness of upper side\nmaximum_thickness_zl : z-coordinate at maximum thickness of lower side\ncurvature_u : second derivative of surface geometry at maximum thickness of upper side\ncurvature_l : second derivative of surface geometry at maximum thickness of lower side\ntrailing_edge_angle : trailing edge angle\nboattail_angle : boat-tail angle\ntrailing_edge_gap : z-position of center of trailing edge\ntrailing_edge_z : z-distance between upper and lower surface trailing edge points\n\nKeyword Arguments\n\nN::Integer=80 : Number of x stations along chord\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\nparsec(p::AbstractArray{Float}; N::Integer=80, split=false)\n\nCalculate the x,z airfoil coordinates for both top and bottom surfaces using standard PARSEC Parameterization method.\n\nUse parsec() for modified PARSEC implementation.\n\nArguments\n\np::AbstractArray{Float} : PARSEC paramters including:\nleading_edge_radius : Leading edge radius\nmaximum_thickness_xu : chordwise position of maximum thickness of upper side\nmaximum_thickness_xl : chordwise position of maximum thickness of lower side\nmaximum_thickness_zu : z-coordinate at maximum thickness of upper side\nmaximum_thickness_zl : z-coordinate at maximum thickness of lower side\ncurvature_u : second derivative of surface geometry at maximum thickness of upper side\ncurvature_l : second derivative of surface geometry at maximum thickness of lower side\ntrailing_edge_angle : trailing edge angle\nboattail_angle : boat-tail angle\ntrailing_edge_gap : z-position of center of trailing edge\ntrailing_edge_z : z-distance between upper and lower surface trailing edge points\n\nKeyword Arguments\n\nN::Integer=80 : Number of x stations along chord\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For a given set of x,z coordinates a best-fit PARSEC airfoil can be found using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.determine_parsec","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.determine_parsec","text":"determine_parsec(x,z)\n\nUses LsqFit to go from x-z coordinates to standard PARSEC parameters.\n\nArguments\n\nx::AbstractArray{Float} : vector of x coordinates\nz::AbstractArray{Float} : vector of z coordinates\n\nReturns\n\nparameters::PARSEC : an parameter object of type PARSEC\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/#Modified","page":"Airfoil Generation","title":"Modified","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"Also implemented in AirfoilTools is a modified PARSEC parameterization that give direct control to the trailing edge surfaces of the upper and lower sides.  The ModifiedPARSEC type is defined as","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.ModifiedPARSEC","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.ModifiedPARSEC","text":"ModifiedPARSEC\n\nFields\n\nleading_edge_radius::Float : leading edge radius\nmaximum_thickness_xu::Float : x-position of maximum thickness for upper side.\nmaximum_thickness_xl::Float : x-position of maximum thickness for lower side.\nmaximum_thickness_zu::Float : value of maximum thickness (from zero) for upper side.\nmaximum_thickness_zl::Float : value of maximum thickness (from zero) for lower side.\ncurvature_u::Float : curvature at point of maximum thickness on upper side.\ncurvature_l::Float : curvature at point of maximum thickness on lower side.\ntrailing_edge_tangent_u::Float : angle of surface at upper side trailing edge.\ntrailing_edge_tangent_l::Float : angle of surface at lower side trailing edge.\ntrailing_edge_zu::Float=0.0 : z-position of upper side trailing edge.\ntrailing_edge_zl::Float=0.0 : z-position of lower side trailing edge.\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"A Modified PARSEC airfoil can be generated with","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.modified_parsec","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.modified_parsec","text":"parsec(p::ModifiedPARSEC; N::Int=80, split=false)\n\nCalculate the x,y airfoil coordinates for both top and bottom surfaces using modified PARSEC Parameterization method.\n\nUse parsec() for standard PARSEC implementation.  This modified version employs direct values for trailing edge position and angles for each surface.\n\nArguments\n\np::ModifiedPARSEC : ModifiedPARSEC paramters including:\nleading_edge_radius : Leading edge radius\nmaximum_thickness_xu : chordwise position of maximum thickness of upper side\nmaximum_thickness_xl : chordwise position of maximum thickness of lower side\nmaximum_thickness_zu : z-coordinate at maximum thickness of upper side\nmaximum_thickness_zl : z-coordinate at maximum thickness of lower side\ncurvature_u : second derivative of surface geometry at maximum thickness of upper side\ncurvature_l : second derivative of surface geometry at maximum thickness of lower side\ntrailing_edge_tangent_u : trailing edge tangent angle of upper side\ntrailing_edge_tangent_l : trailing edge tangent angle of lower side\ntrailing_edge_zu : z-position of trailing edge of upper side\ntrailing_edge_zl : z-position of trailing edge of lower side\n\nKeyword Arguments\n\nN::Integer=80 : Number of x stations along chord\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\nparsec(p::AbstractArray{Float}; N::Int=80, split=false)\n\nCalculate the x,y airfoil coordinates for both top and bottom surfaces using modified PARSEC Parameterization method.\n\nUse parsec() for standard PARSEC implementation.  This modified version employs direct values for trailing edge position and angles for each surface.\n\nArguments\n\np::AbstractArray{Float} : ModifiedPARSEC paramters including:\nleading_edge_radius : Leading edge radius\nmaximum_thickness_xu : chordwise position of maximum thickness of upper side\nmaximum_thickness_xl : chordwise position of maximum thickness of lower side\nmaximum_thickness_zu : z-coordinate at maximum thickness of upper side\nmaximum_thickness_zl : z-coordinate at maximum thickness of lower side\ncurvature_u : second derivative of surface geometry at maximum thickness of upper side\ncurvature_l : second derivative of surface geometry at maximum thickness of lower side\ntrailing_edge_tangent_u : trailing edge tangent angle of upper side\ntrailing_edge_tangent_l : trailing edge tangent angle of lower side\ntrailing_edge_zu : z-position of trailing edge of upper side\ntrailing_edge_zl : z-position of trailing edge of lower side\n\nKeyword Arguments\n\nN::Integer=80 : Number of x stations along chord\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns\n\nIf split == false:\n\nx::AbstractArray{Float} : Vector of x coordinates, clockwise from trailing edge.\nz::AbstractArray{Float} : Vector of z coordinates, clockwise from trailing edge.\n\nIf split == true:\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates from trailing edge to leading edge.\nxu::AbstractArray{Float} : Vector of upper half of x coordinates from leading edge to trailing edge.\nzl::AbstractArray{Float} : Vector of lower half of z coordinates from trailing edge to leading edge.\nzu::AbstractArray{Float} : Vector of upper half of z coordinates from leading edge to trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"For a given set of x,z coordinates a best-fit Modified PARSEC airfoil can be found using","category":"page"},{"location":"AirfoilTools/parameterizations/#FLOWFoil.AirfoilTools.determine_modified_parsec","page":"Airfoil Generation","title":"FLOWFoil.AirfoilTools.determine_modified_parsec","text":"determine_modified_parsec(x,z)\n\nUses LsqFit to go from x-z coordinates to modified ModifiedPARSEC parameters.\n\nArguments\n\nx::AbstractArray{Float} : vector of x coordinates\nz::AbstractArray{Float} : vector of z coordinates\n\nReturns\n\nparameters::ModifiedPARSEC : an parameter object of type ModifiedPARSEC\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/parameterizations/#Contributing","page":"Airfoil Generation","title":"Contributing","text":"","category":"section"},{"location":"AirfoilTools/parameterizations/","page":"Airfoil Generation","title":"Airfoil Generation","text":"We welcome the addition of other common parameterizations. Additions should have outputs consistent with current parameterizations.","category":"page"},{"location":"FLOWFoil/public_api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"FLOWFoil/public_api/#Analyze","page":"Public API","title":"Analyze","text":"","category":"section"},{"location":"FLOWFoil/public_api/#FLOWFoil.analyze-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.analyze","text":"analyze(coordinates, flow_angles=0.0, reynolds=1e6, mach=0.0; method::Method=Mfoil())\nanalyze(x, y, flow_angles=0.0, reynolds=1e6, mach=0.0; method::Method=Mfoil())\n\nConvenience function for setting up, solving, and post-processing airfoils and airfoil systems.\n\nArguments\n\ncoordinates::NTuple{Matrix{Float}} : Tuple of [x y] matrices of airfoil coordinates (may be a single matrix as well)\nflow_angles::Vector{Float} : Vector of angles of attack (may be a single float as well)\n\nOR\n\nx::Vector{Float} : Vector of x-coordinates of airfoil geometry\ny::Vector{Float} : Vector of y-coordinates of airfoil geometry\nflow_angles::Vector{Float} : Vector of angles of attack (may be a single float as well)\n\nNote that inputting separate vectors for airfoil coordinates is only available for analysis of single airfoils/bodies.  Multi-airfoil/body systems require the use of a tuple of matrices for coordinate inputs.\n\nKeyword Arguments\n\nmethod::MethodType : desired method for solving\n\nReturns\n\noutputs::OutputType : outputs object (note that only inviscid methods are currently implemented)\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/public_api/#Methods","page":"Public API","title":"Methods","text":"","category":"section"},{"location":"FLOWFoil/public_api/","page":"Public API","title":"Public API","text":"FLOWFoil provides access to the following methods.","category":"page"},{"location":"FLOWFoil/public_api/#FLOWFoil.Mfoil-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.Mfoil","text":"Mfoil <: Method\n\nFields\n\nviscous::Bool : Flag whether to run an inviscid (false) or viscous (true) analysis.\n\nNOTE: viscous method not yet implemented.\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.Lewis-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.Lewis","text":"Lewis <: Method\n\nFields\n\nbody_of_revolution::AbstractVector{Bool} : Flag(s) whether bodies are bodies of revolutions or not (false indicates an annular airfoil)\n\nNote that if multiple bodies are used, the annular airfoil should come before the body of revolution.\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.Martensen-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.Martensen","text":"Martensen <: Method\n\nFields\n\ncascade::Bool=true : flag to apply cascade treatment or not\nsolidity::Float=0.0 : Ratio between airfoil chord length and pitch. Airfoil pitch is simply the distance between chordlines in the cascade.\nstagger::Float=0.0 : Angle (in degrees) from axis of ration to airfoil chordline. Note that stagger is equivalent to the inflow angle minus the angle of attack.\ntransition_value::Float=Inf : pitchtochord ratio at which we stop applying cascade effects (Lewis uses 30 in his implementation)\ncurvature_correction::Bool=false : flag to apply curvature correction from Lewis\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.HessSmith-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.HessSmith","text":"HessSmith <: Method\n\nFields\n\nV_inf::TF=1.0 : magnitude of the free stream velocity\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.LegacyXfoil-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.LegacyXfoil","text":"LegacyXfoil <: Method\n\nIn general usage, this struct is generated by calling the LegacyXfoil constructor.\n\nFields\n\nreynolds: Reynolds number\nmach: Mach number\nxtrip: forced transition x/c locations on top/bottom sides\nreinit: reinitialize the solution? (rather than use the previous solution)\niter: Maximum iterations for viscous analyses\nnpan: Number of panels\npercussive_maintenance: Call do_percussive_maintenance upon  convergence failure?\nprintdata: Print data obtained from XFOIL during the solution?\nzeroinit: Start angle of attack sweeps from zero?  If true, results will be sorted by ascending angle of attack.\nclmaxstop: Stop if lift coefficient decreases twice consecutively going up?\nclminstop: Stop if lift coefficient increases twice consecutively going down?\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.NeuralFoil-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.NeuralFoil","text":"NeuralFoil <: Method\n\nIn general usage, this struct is generated by calling the NeuralFoil constructor.\n\nFields:\n\nRe::Float\nMa::Float\nn_crit::Float\nxtr_upper::Float\nxtr_lower::Float\nnet_cache::NeuralFoil.NetParameters\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#Outputs","page":"Public API","title":"Outputs","text":"","category":"section"},{"location":"FLOWFoil/public_api/","page":"Public API","title":"Public API","text":"Based on the method used, FLOWFoil returns one of the following types:","category":"page"},{"location":"FLOWFoil/public_api/#FLOWFoil.InviscidOutputs-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.InviscidOutputs","text":"InviscidOutputs\n\nNote: not all methods return values for all outputs.  Methods will return zeros in such cases.\n\nFields\n\nvs: surface velocities on each body, nominally a matrix, but becomes a vector of matrices in the multi-body case with dimensions [body][panel,angle]\ncp: pressure coefficient for each panel of each body, becomes a vector of matrices in the multi-body case with dimensions [body][panel,angle]\ncl: lift coefficient of each body, nominally a vector but becomes a matrix in the multi-body case with dimensions angle x body\ncd: total drag coefficient of each body, but becomes a matrix in the multi-body case with dimensions angle x body\ncm: moment coefficient of each body, but becomes a matrix in the multi-body case with dimensions angle x body\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/#FLOWFoil.LegacyXFOutputs-FLOWFoil-public_api","page":"Public API","title":"FLOWFoil.LegacyXFOutputs","text":"LegacyXFOutputs\n\nFields\n\ncl::Vector{Float}\ncd::Vector{Float}\ncdp::Vector{Float}\ncm::Vector{Float}\nconverged::Vector{Bool}\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/public_api/","page":"Public API","title":"Public API","text":"Or in the case of NeuralFoil, the native NeuralFoil output (NeuralOutputs) type will be returned","category":"page"},{"location":"FLOWFoil/additional_tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"FLOWFoil includes various panel method implementations that are available based on the method keyword argument. Here we go over the available methods and their various options","category":"page"},{"location":"FLOWFoil/additional_tutorials/#Mfoil-(inviscid)-Method","page":"Tutorials","title":"Mfoil (inviscid) Method","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"An Xfoil-like method, actually based on mfoil can be accessed using the Mfoil method type:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.Mfoil","page":"Tutorials","title":"FLOWFoil.Mfoil","text":"Mfoil <: Method\n\nFields\n\nviscous::Bool : Flag whether to run an inviscid (false) or viscous (true) analysis.\n\nNOTE: viscous method not yet implemented.\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"Note that we have also set Xfoil=Mfoil so you can also use the Xfoil method type with identical results. Currently, this method only includes the inviscid methods of Xfoil/Mfoil.","category":"page"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, y = AirfoilTools.naca4()\n\nangles_of_attack = range(-5.0, 15.0; step=1)\n\n# viscous solver not yet implemented\nmethod = Mfoil(viscous=false)\n\noutputs = analyze(x, y, angles_of_attack; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/#Lewis'-Method-for-Axisymmetric-Bodies","page":"Tutorials","title":"Lewis' Method for Axisymmetric Bodies","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"An axisymmetric method based on that described by Lewis can be accessed using the Lewis method type:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.Lewis","page":"Tutorials","title":"FLOWFoil.Lewis","text":"Lewis <: Method\n\nFields\n\nbody_of_revolution::AbstractVector{Bool} : Flag(s) whether bodies are bodies of revolutions or not (false indicates an annular airfoil)\n\nNote that if multiple bodies are used, the annular airfoil should come before the body of revolution.\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, r = AirfoilTools.naca4()\n\n# give the duct some diameter (see note below)\nr .+= 1.0\n\n# indicate that the body is not a body of revolution (i.e. a duct)\nmethod = Lewis(; body_of_revolution=[false])\n\n# note: we need to input an an angle of attack, even though it is unused\noutputs = analyze(x, r, [0.0]; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nNo part of the geometry for an axisymmetric body can reside below z=0, otherwise an error will be thrown.","category":"page"},{"location":"FLOWFoil/additional_tutorials/#Martensen's-Method-for-Periodic-Bodies-(Cascades)","page":"Tutorials","title":"Martensen's Method for Periodic Bodies (Cascades)","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"A periodic method for cascade analysis based on that developed by Martensen can be accessed using the Martensen method type:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.Martensen","page":"Tutorials","title":"FLOWFoil.Martensen","text":"Martensen <: Method\n\nFields\n\ncascade::Bool=true : flag to apply cascade treatment or not\nsolidity::Float=0.0 : Ratio between airfoil chord length and pitch. Airfoil pitch is simply the distance between chordlines in the cascade.\nstagger::Float=0.0 : Angle (in degrees) from axis of ration to airfoil chordline. Note that stagger is equivalent to the inflow angle minus the angle of attack.\ntransition_value::Float=Inf : pitchtochord ratio at which we stop applying cascade effects (Lewis uses 30 in his implementation)\ncurvature_correction::Bool=false : flag to apply curvature correction from Lewis\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nIf the cascade option is set to false, this method becomes a standard planar airfoil method, but uses constant vortices, so the Mfoil/Xfoil method is the superior method in that case.","category":"page"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, y = AirfoilTools.naca4()\n\nangles_of_attack = range(-5.0, 15.0; step=1)\n\n# The cascade method requires solidity (closeness) of sections and stagger (inflow angle - angle of attack)\nmethod = Martensen(solidity=1.2, stagger=15.0)\n\noutputs = analyze(x, y, angles_of_attack; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/#Hess-Smith-2D-Method","page":"Tutorials","title":"Hess-Smith 2D Method","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"We also have a version of the Hess-Smith method primarily for educational use that can be accessed with the HessSmith method type:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.HessSmith","page":"Tutorials","title":"FLOWFoil.HessSmith","text":"HessSmith <: Method\n\nFields\n\nV_inf::TF=1.0 : magnitude of the free stream velocity\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, y = AirfoilTools.naca4()\n\nangles_of_attack = range(-5.0, 15.0; step=1)\n\nmethod = HessSmith(V_inf=1.0)\n\noutputs = analyze(x, y, angles_of_attack; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/#NeuralFoil-Method","page":"Tutorials","title":"NeuralFoil Method","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"NeuralFoil is a multi-layer perceptron model of Xfoil. We provide the Neuralfoil Method through the NeuralFoil method type and is accessed through the neuralfoil.jl:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.NeuralFoil","page":"Tutorials","title":"FLOWFoil.NeuralFoil","text":"NeuralFoil <: Method\n\nIn general usage, this struct is generated by calling the NeuralFoil constructor.\n\nFields:\n\nRe::Float\nMa::Float\nn_crit::Float\nxtr_upper::Float\nxtr_lower::Float\nnet_cache::NeuralFoil.NetParameters\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.NeuralFoil-Tuple{Any}","page":"Tutorials","title":"FLOWFoil.NeuralFoil","text":"NeuralFoil(\n    reynolds=1e6, mach=0.0; model_size=\"xlarge\", n_crit=9.0, xtr_upper=1.0, xtr_lower=1.0\n)\n\nConstructor for NeuralFoil type.\n\nDefault Arguments\n\nreynolds::Float=1e6 : Reynolds number\nmach::Float=0.0 : Mach number\n\nKeyword Arguments\n\nmodel_size::String=\"xlarge\" : model size from NeuralFoil\nn_crit::Float=9.0 : n_crit for Xfoil\nxtr_upperFloat=1.0 : Xtr_Upper for Xfoil\nxtr_lowerFloat=1.0 : Xtr_Lower for Xfoil\n\nReturns\n\nmethod::NeuralFoil : NeuralFoil method object\n\nNeuralFoil Method Fields:\n\nRe::Vector{Float} : Reynolds Number(s)\nMa::Float=0.0 : Mach Number\n`n_crit::Float=9.0' : n for e^n transition model\n`xtr_upper::Float=1.0' : location for forced trip to turbulent, upper side\n`xtr_lower::Float=1.0' : location for forced trip to turbulent, lower side\nnet_cache::NeuralFoil.NetParameters : NeuralFoil network parameters based on model size\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, y = AirfoilTools.naca4()\n\nangles_of_attack = range(-5.0, 15.0; step=1)\n\nreynolds = 2e6\nmach = 0.0\n\nmethod = NeuralFoil(reynolds, mach; model_size=\"xlarge\", n_crit=9.0, xtr_upper=1.0, xtr_lower=1.0)\n\noutputs = analyze([x y], angles_of_attack; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"Note that the NeuralFoil method does not allow multi-body analysis like the other methods do as it is based specifically on Xfoil.  We also return a separate output type for the NeuralFoil method from the NeuralFoil.jl namespace.","category":"page"},{"location":"FLOWFoil/additional_tutorials/#LegacyXfoil-Method","page":"Tutorials","title":"LegacyXfoil Method","text":"","category":"section"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"We also have the LegacyXfoil method that is based on Xfoil and can be accessed with the LegacyXfoil method type:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.LegacyXfoil","page":"Tutorials","title":"FLOWFoil.LegacyXfoil","text":"LegacyXfoil <: Method\n\nIn general usage, this struct is generated by calling the LegacyXfoil constructor.\n\nFields\n\nreynolds: Reynolds number\nmach: Mach number\nxtrip: forced transition x/c locations on top/bottom sides\nreinit: reinitialize the solution? (rather than use the previous solution)\niter: Maximum iterations for viscous analyses\nnpan: Number of panels\npercussive_maintenance: Call do_percussive_maintenance upon  convergence failure?\nprintdata: Print data obtained from XFOIL during the solution?\nzeroinit: Start angle of attack sweeps from zero?  If true, results will be sorted by ascending angle of attack.\nclmaxstop: Stop if lift coefficient decreases twice consecutively going up?\nclminstop: Stop if lift coefficient increases twice consecutively going down?\n\n\n\n\n\n","category":"type"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.LegacyXfoil-Tuple{Any}","page":"Tutorials","title":"FLOWFoil.LegacyXfoil","text":"LegacyXfoil(\n    reynolds,\n    mach=0.0;\n    xtrip=(1.0, 1.0),\n    reinit=false,\n    iter=50,\n    npan=140,\n    percussive_maintenance=!reinit,\n    printdata=false,\n    zeroinit=true,\n    clmaxstop=false,\n    clminstop=false,\n)\n\nConstructor for LegacyXfoil type.\n\nArguments\n\nreynolds::Float=1e6 : Reynolds number\n\nDefault Arguments\n\nmach::Float=0.0 : Mach number\n\nKeyword Arguments\n\nxtrip::Tuple{Float, Float}=(1.0,1.0): forced transition x/c locations on top/bottom sides\nreinit::Bool=false: reinitialize the solution? (rather than use the previous solution)\niter::Int=50: Maximum iterations for viscous analyses\nnpan::Int=140: Number of panels\npercussive_maintenance::Bool=!reinit: Call do_percussive_maintenance upon convergence failure?\nprintdata::Bool=false: Print data obtained from XFOIL during the solution?\nzeroinit::Bool=true: Start angle of attack sweeps from zero?  If true, results will be sorted by ascending angle of attack.\nclmaxstop::Bool=false: Stop if lift coefficient decreases twice consecutively going up?\nclminstop::Bool=false: Stop if lift coefficient increases twice consecutively going down?\n\nReturns\n\nmethod::LegacyXfoil : LegacyXfoil method object\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"using FLOWFoil\n\nx, y = AirfoilTools.naca4()\n\nangles_of_attack = range(-5.0, 15.0; step=1)\n\nreynolds = 2e6\n\nmethod = LegacyXfoil(reynolds; npan=140)\n\noutputs = analyze([x y], angles_of_attack; method=method)","category":"page"},{"location":"FLOWFoil/additional_tutorials/","page":"Tutorials","title":"Tutorials","text":"Note that we return a separate output type for the LegacyXFoil method:","category":"page"},{"location":"FLOWFoil/additional_tutorials/#FLOWFoil.LegacyXFOutputs","page":"Tutorials","title":"FLOWFoil.LegacyXFOutputs","text":"LegacyXFOutputs\n\nFields\n\ncl::Vector{Float}\ncd::Vector{Float}\ncdp::Vector{Float}\ncm::Vector{Float}\nconverged::Vector{Bool}\n\n\n\n\n\n","category":"type"},{"location":"AirfoilTools/api/#Public","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"AirfoilTools/api/","page":"API Reference","title":"API Reference","text":"Modules = [AirfoilTools]\nOrder = [:type,:function]","category":"page"},{"location":"AirfoilTools/api/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.bernstein-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.bernstein","text":"bernstein(r, n, x)\n\nBernstein Basis Function: binomial(n, r) .* x .^ r .* (1 .- x) .^ (n .- r)\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.calculate_modified_parsec_coefficients","page":"API Reference","title":"FLOWFoil.AirfoilTools.calculate_modified_parsec_coefficients","text":"calculate_modified_parsec_coefficients(p, uppper_side)\n\nCalculate the PARSEC coefficients using modified parameters (see parsec() docstring) for either the top or bottom curve.\n\nArguments\n\np::NamedTuple : Named tuple of ModifiedPARSEC paramters including:\nleading_edge_radius::Float : Leading edge radius\nmaximum_thickness_x::Float : chordwise position of maximum thickness\nmaximum_thikcness_z::Float : z-coordinate at maximum thickness\ncurvature::Float : second derivative of surface geometry at maximum thickness\ntrailing_edge_tangent::Float : trailing edge tangent angle, radians\ntrailing_edge_z::Float : z-position of trailing edge\nside::Number : +1 for upper side, -1 for lower side\n\nReturns\n\ncoefficients::Vector{Float}: Vector of 6 PARSEC polynomial coefficients that define the airfoil surface for the specified side.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.calculate_parsec_coefficients","page":"API Reference","title":"FLOWFoil.AirfoilTools.calculate_parsec_coefficients","text":"calculate_parsec_coefficients(p, side=1)\n\nCalculate the PARSEC coefficients using standard parameters (see parsec() docstring) for either the top or bottom curve.\n\nArguments\n\np::NamedTuple : NamedTuple of PARSEC standard paramters including:\n[1]: leading_edge_radius : Leading edge radius\n[2]: X : chordwise position of maximum thickness\n[3]: Z : z-coordinate at maximum thickness\n[4]: curvature : second derivative of surface geometry at maximum thickness\n[5]: trailing_edge_angle : trailing edge angle\n[6]: boattail_angle : boat-tail angle\n[7]: trailing_edge_gap : z-distance between upper and lower surface trailing edge points\n[8]: trailing_edge_z : z-position of center of trailing edge\n\nReturns\n\ncoefficients::Vector{Float}: Vector of 6 PARSEC polynomial coefficients that define the airfoil surface for the specified side.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.computed_camber_line-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.computed_camber_line","text":"computed_camber_line(\na,\ncli,\nx\n\n)\n\nThis computes the corresponding camber for a given x value for the NACA 65 series. \n\nArguments\n\na::TF : Mean-line designation, fraction of chord from leading edge over which design load is uniform. Should be listed in the airfoil descirption\ncli::TF : Design lift coefficient in tenths of chord. Usually first number after the 2nd dash (ie NACA 65-3-818 would input 0.8 for cli)\nx::TF : x value (note that x must be normalized by the chord length)\n\nReturns\n\nyc::Float : Amount of camber y_c for a given x value on the airfoil\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.definespline-NTuple{5, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.definespline","text":"definespline(leading_edge_radius, trailing_edge_camber_angle, wedge_angle, trailing_edge_gap, third_ctrlpt_position)\n\nCalculate the x and y location of the control points, and weight them according to the weighting vector. Also, provide generic knot vectors.\n\nArguments\n\nleadingedgeradius::Float : Leading edge radius\ntrailingedgecamber_angle::Float : trailing edge camber angle in degrees\nwedge_angle::Float : The trailing edge wedge angle in degrees\ntrailingedgegap::Float : The trailing edge gap\nthirdctrlptposition::Float : x position of the 2nd and 6th control points in degree 3.\n\nReturns\n\nknots::AbstractArray{Float}: The knot vector of the curve.\ncontrolpoints::AbstractArray{Tuple{Float,3}}: The control point vector, where each point is a tuple of (x, y, w).\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.determine_half_cst-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.determine_half_cst","text":"determine_half_cst(x, z; n_coefficients=8, trailing_edge_z=0.0, N1=0.5, N2=1.0)\n\nDetermine best-fit CST parameters for half of the airfoil using a least squares solve.\n\nArguments\n\nx::AbstractArray{Float} : vector of x coordinates for airfoil\nz::AbstractArray{Float} : vecotr of z coordinates for airfoil\n\nKeyword Arguments\n\nn_coefficients::Int=8 : number of coefficients to fit\ntrailing_edge_z::Float=0.0 : z coordinate of trailing edge\nN1::Float=0.5 : Class Shape Parameter 1\nN2::Float=1.0 : Class Shape Parameter 2\n\nReturns\n\nparameters::CST : CST parameters for airfoil\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.dot-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.dot","text":"dot(A, B) = sum(a * b for (a, b) in zip(A, B))\n\nA faster dot product.\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.get_spline_coordinates-Tuple{Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.get_spline_coordinates","text":"get_spline_coordinates(nurbs; N=80)\n\nCompute and return plottable coordinates from a NURBS (Non-Uniform Rational B-Spline) curve.\n\nArguments\n\nnurbs::NURBS: A NURBS curve object with fields:\nknots::AbstractVector{Float64}: Knot vector\ncontrolPoints::AbstractMatrix{Float64}: Weighted control points (each column is a point)\ndegree::Int: Degree of the curve\n\nKeyword Arguments\n\nN::Int=80: Number of segments (returns N + 1 sampled points)\n\nReturns\n\nx::Vector{Float64}: x-coordinates of the sampled curve\nz::Vector{Float64}: z-coordinates of the sampled curve\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.half_cst","page":"API Reference","title":"FLOWFoil.AirfoilTools.half_cst","text":"half_cst(coefficients, x=cosine_spacing(N), dz=0.0, N1=0.5, N2=1.0)\n\nDefine upper or lower side of airfoil using CST parameterization.\n\nArguments:\n\ncoefficients::AbstractArray{Float} : Vector of CST coefficients.\n\nKeyword Arguments:\n\ndz::Float=0.0 : trailing edge gap\nN1::Float=0.5 : Class shape parameter 1\nN2::Float=1.0 : Class shape parameter 2\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.joukowsky_flow-NTuple{4, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.joukowsky_flow","text":"joukowsky_flow(center, radius, alpha, vinf; N=361)\n\nCalculate the analytic surface velocities and pressures as well as lift coefficient for a joukowsky airfoil.\n\nArguments\n\ncenter::AbstractArray{Float} : [x z] location of circle center relative to origin\nradius::Float : Radius of circle\nalpha::Float : Angle of attack in degrees\nvinf::Float : Freestream velocity\n\nKeyword Arguments\n\nN::Int=361 : Total number of coordinates to use. Can be even or odd, but it is recommended to be odd for a clear leading edge point.\n\nReturns\n\nvsurf::AbstractArray{Float} : Magnitude of surface velocities at the nodes\ncpsurf::AbstractArray{Float} : Surface pressures at the nodes\ncl::Float : Lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.naca4_camber-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.naca4_camber","text":"naca4_camber(x, max_camber, max_camber_pos)\n\nCompute camber at a given chord-normalized x-position by NACA 4-series camber equations.\n\nArguments\n\nx::Float : x position along chordline\nmax_camber::Float64 : Maximum camber value\nmax_camber_pos::Float64 : Position of maximum camber\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.naca4_thickness-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.naca4_thickness","text":"naca4_thickness(x, maxthick; blunt_te=false)\n\nCompute thickness at a given chord-normalized x-position by NACA 4-series thickness equations.\n\nArguments\n\nx::Float : x position along chordline, markersize=3, markershape=:squaree\nmaxthick::Float : Maximum thickness value\n\nKeyword Arguments\n\nblunt_te::Bool=false : Flag whether trailing edge is blunt or not\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.norm-Tuple{Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.norm","text":"norm(A) = sqrt(mapreduce(x -> x^2, +, A))\n\nA faster 2-norm.\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.scaled_camber-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.scaled_camber","text":"From NACA Research Memorandum L51G31: \"Systematic Two-dimensional Cascade Tests of NACA 65-Series Compressor Blades at Low Speeds\" Table 2\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.scaled_slope-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.scaled_slope","text":"From NACA Research Memorandum L51G31: \"Systematic Two-dimensional Cascade Tests of NACA 65-Series Compressor Blades at Low Speeds\" Table 2\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.scaled_thickness-Tuple{Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.scaled_thickness","text":"From NACA Research Memorandum L51G31: \"Systematic Two-dimensional Cascade Tests of NACA 65-Series Compressor Blades at Low Speeds\" Table 1\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.slopes65-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.slopes65","text":"slopes65(\nx,\nclo,\na;\nslope_tolerance = 0.000001\n\n)\n\nThis computes the corresponding slopes of the mean line for a given x value on the airfoil\n\nArguments\n\nx::TF : x value (note that x must be normalized by the chord length)\nclo::TF : Design lift coefficient in tenths of chord. Usually first number after the 2nd dash (ie NACA 65-3-818 would input 0.8 for cli)\na::TF : Mean-line designation, fraction of chord from leading edge over which design load is uniform. Should be listed in the airfoil descirption\n\nKeyword Arguments\n\nslope_tolerance::Float = 0.000001 : step size taken for the derivative\n\nReturns\n\ntan_theta::Float : Tangent of the mean line slope\nsin_theta::Float : Sine of the mean line slope\ncos_theta::Float : Cosine of the mean line slope\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.thickness65-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.AirfoilTools.thickness65","text":"thickness65(\nseries_number,\nxpt #value of x that the desired y_t is\n\n)\n\nThis computes the thicknes coordinate and leading edge radius from tabulated thickness forms\n\nArguments\n\nseries_number::String : Airfoil series number (see naca65 doc string for more details)\nxpt::TF : Desired x value to compute the thickness value\n\nReturns\n\ny_t::Float : thickness value at specified x value\nleading_edge_radius::Float : Tabulated leading edge thickness - make sure it is in x/c units!\n\n\n\n\n\n","category":"method"},{"location":"AirfoilTools/api/#FLOWFoil.AirfoilTools.z_from_parsec_coefficients","page":"API Reference","title":"FLOWFoil.AirfoilTools.z_from_parsec_coefficients","text":"z_from_parsec_coefficients(a, N::Int=80)\n\nCalculate the x,z airfoil coordinates using the PARSEC polynomial.\n\nArguments\n\na::AbstractArray{Float} : the PARSEC coefficients.\n\nKeyword Arguments\n\nN::Int=80 : number of coordinates\n\nReturns\n\nz::AbstractArray{Float} : vector of z coordinates of the airfoil\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#Airfoil-Geometry-Manipulation-Tools","page":"Airfoil Manipulation","title":"Airfoil Geometry Manipulation Tools","text":"","category":"section"},{"location":"AirfoilTools/geometry_manipulations/","page":"Airfoil Manipulation","title":"Airfoil Manipulation","text":"Here we include the variety of methods for manipulating airfoil geometries in useful ways implemented in AirfoilTools.","category":"page"},{"location":"AirfoilTools/geometry_manipulations/#Deconstruction","page":"Airfoil Manipulation","title":"Deconstruction","text":"","category":"section"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.split_upper_lower","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.split_upper_lower","text":"split_upper_lower(x, z; idx::Integer=nothing)\n\nSplit the upper and lower halves of the airfoil coordinates.\n\nAssumes leading edge point is at first minimum x value if idx is not provided. Returns the upper and lower coordinates each with the leading edge point. Assumes airfoil is defined clockwise starting at the trailing edge.\n\nArguments\n\nx::AbstractArray{Float} : Vector of x coordinates\nz::AbstractArray{Float} : Vector of z coordinates\n\nKeyword Arguments\n\nidx::Integer : optional index at which to split the coordinates\n\nReturns\n\nxl::AbstractArray{Float} : Vector of lower half of x coordinates\nxu::AbstractArray{Float} : Vector of upper half of x coordinates\nzl::AbstractArray{Float} : Vector of lower half of z coordinates\nzu::AbstractArray{Float} : Vector of upper half of z coordinates\n\n\n\n\n\nsplit_upper_lower(coordaintes; idx::Integer=nothing)\n\nSplit the upper and lower halves of the airfoil coordinates.\n\nAssumes leading edge point is at first minimum x value if idx is not provided. Returns the upper and lower coordinates each with the leading edge point. Assumes airfoil is defined clockwise starting at the trailing edge.\n\nArguments\n\ncoordinates::Matrix{Float} : Matrix of [x z] coordinates\n\nKeyword Arguments\n\nidx::Integer : optional index at which to split the coordinates\n\nReturns\n\nxl::AbstractArray{Float} : View of lower half of x coordinates\nxu::AbstractArray{Float} : View of upper half of x coordinates\nzl::AbstractArray{Float} : View of lower half of z coordinates\nzu::AbstractArray{Float} : View of upper half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#Transformation","page":"Airfoil Manipulation","title":"Transformation","text":"","category":"section"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.flip!","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.flip!","text":"flip!(x)\n\nFlips one dimension of airfoil coordinates.\n\nMoves airfoil left (x) or down (z) by maximum x or z coordinate then flips about the z or x axis, respectively.\n\nArguments\n\nx::AbstractArray{Float} : vector of x or z coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.zero_z_te!","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.zero_z_te!","text":"zero_z_te!(coordinates)\n\nPlaces trailing edge on the x-axis.\n\nArguments\n\ncoordinates::Array{Float} : Array of [x z] coordinates to be updated in place.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.rotate_coordinates!","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.rotate_coordinates!","text":"rotate_coordinates!(coordinates, angle; rotation_point=[0.0; 0.0])\n\nRotate coordiantes clockwise about rotation_point by angle in degrees.\n\nArguments\n\ncoordinates::Array{Float} : Array of [x z] coordinates to be updated in place.\nangle::Float=0.0 : Angles, in degrees, by which to rotate the coordinates clockwise (positive angle will pitch airfoil up).\n\nKeyword Arguments\n\nrotation_point::AbstractArray{Float}=[0.0; 0.0] : Array of [x z] position of point about which to perform rotation.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.normalize_coordinates!","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.normalize_coordinates!","text":"normalize_coordinates!(coordinates)\n\nNormalize airfoil to unit chord and shift leading edge to zero. Adjusts coordinates in place.\n\nArguments\n\ncoordinates::AbstractArray{Float} : Array of [x z] coordinates\n\n\n\n\n\nnormalize_coordinates!(x, z)\n\nNormalize airfoil to unit chord and shift leading edge to zero. Adjusts coordinates in place.\n\nArguments\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.position_coordinates!","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.position_coordinates!","text":"position_coordinates!(coordinates, scale, angle, location)\n\nScale, Rotate, and Transform (in that order) airfoil coordinates.\n\nArguments\n\ncoordinates::Array{Float} : Array of [x z] coordinates to be updated in place.\n\nKeyword Arguments\n\nscale::Float=1.0 : Value by which to scale coordinates.\nangle::Float=0.0 : Angles, in degrees, by which to rotate the coordinates clockwise (positive angle will pitch airfoil up).\nlocation::AbstractArray{Float}=[0.0; 0.0] : Array of [x z] position of leading edge location.\nrotation_point::AbstractArray{Float}=[0.0; 0.0] : Array of [x z] position of point about which to perform rotation.\nflipped::Bool : flag whether to flip airfoil upside down.\n\nReturns\n\nx::Array{Float} : array of x-coordinates\nz::Array{Float} : array of z-coordinates\n\n\n\n\n\nposition_coordinates!(\n    coordinates::Vector{AbstractArray{TF}};\n    scales=[1.0],\n    angles=[0.0],\n    locations=[[0.0; 0.0],],\n    rotation_points=[[0.0; 0.0],],\n    flipped=[false],\n) where {TF}\n\nMulti-airfoil version of position_coordinates!.\n\nIf keyword arguments are give as single valued vectors, the same values are used for all coordinate sets. If keyword arguments are provided as vectors of length greater than 1, they must have the same length as the set of coordinates. For example, if scaling 3 airfoils, there will be a vector of 3 airfoil coordinate sets input and scales must either be a one element vector or a vector of length 3.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#Re-definition","page":"Airfoil Manipulation","title":"Re-definition","text":"","category":"section"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.whole_cosine_spacing","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.whole_cosine_spacing","text":"whole_cosine_spacing(N::Integer=160)\n\nReturns cosine spaced x coordinates from 1 to 0 back to 1.\n\nArguments\n\nN::Integer : Total number of points is N+1.\n\nReturns\n\nx::AbstractArray{Float} : cosine spaced x-coordinates, starting at 1.0, going to 0.0, then back to 1.0.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.split_cosine_spacing","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.split_cosine_spacing","text":"split_cosine_spacing(N::Integer=80)\n\nReturns cosine spaced x coordinates from 0 to 1.\n\nArguments\n\nN::Integer : Number of points.\n\nReturns\n\nx::AbstractArray{Float} : cosine spaced x-coordinates, starting at 0.0 ending at 1.0.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.repanel_airfoil","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.repanel_airfoil","text":"repanel_airfoil(x, z; N=160)\n\nRepanels airfoil coordinates using Akima splines with N coordinate points.\n\nArguments\n\nx::AbstractArray{Float} : vector containing the x coordinates of the airfoil\nz::AbstractArray{Float} : vector containing the z coordinates of the airfoil\n\nKeyword Arguements\n\nN::Int : Number of data points to be returned after repaneling. Will only return odd numbers, if N is even, N+1 points will be returned.\n\nReturns\n\nrepaneled_x::AbstractArray{Float} : Repaneled, cosine spaced x corrdinates of the airfoil\nrepaneled_z::AbstractArray{Float} : z coordinates of the repaneled airfoil obtained using an akima spline\n\n\n\n\n\nrepanel_airfoil(coordinates; N=160)\n\nRepanels airfoil coordinates using Akima splines with N coordinate points.\n\nArguments\n\ncoordinates::Array{Float} : Array of [x z] coordinates\n\nKeyword Arguements\n\nN::Int=160 : Number of data points to be returned after repaneling. Will only return odd numbers, if N is even, N+1 points will be returned.\n\nReturns\n\nrepaneled_coordinates::Array{Float} : new coordinate array.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#FLOWFoil.AirfoilTools.refine_trailing_edge","page":"Airfoil Manipulation","title":"FLOWFoil.AirfoilTools.refine_trailing_edge","text":"refine_trailing_edge(coordinates)\n\nAdds points along the trailing edge of an airfoil.\n\nArguments\n\ncoordinates::Array{Float} : Array of [x z] coordinates\n\nReturns\n\nx::AbstractArray{Float} : vector containing the x coordinates of an airfoil with points along the trailing edge.\nz::AbstractArray{Float} : vector containing the z coordinates of an airfoil with points along the trailing edge.\n\n\n\n\n\nrefine_trailing_edge(x, z, N::Integer)\n\nAdds points along the trailing edge of an airfoil\n\nArguments\n\nx::AbstractArray{Float} : vector containing the x coordinates of an airfoil.\nz::AbstractArray{Float} : vecotr containing the z coordinate of an  airfoil.\nN::Integer : Number of data points to be added at the trailing edge.\n\nReturns\n\nx::AbstractArray{Float} : vector containing the x coordinates of an airfoil with points along the trailing edge.\nz::AbstractArray{Float} : vector containing the z coordinates of an airfoil with points along the trailing edge.\n\n\n\n\n\n","category":"function"},{"location":"AirfoilTools/geometry_manipulations/#Contributing","page":"Airfoil Manipulation","title":"Contributing","text":"","category":"section"},{"location":"AirfoilTools/geometry_manipulations/","page":"Airfoil Manipulation","title":"Airfoil Manipulation","text":"We welcome the addition of more convenience functions for airfoil geometry manipulation.","category":"page"},{"location":"AirfoilTools/intro/#Airfoil-Tools","page":"Intro","title":"Airfoil Tools","text":"","category":"section"},{"location":"AirfoilTools/intro/","page":"Intro","title":"Intro","text":"AirfoilTools is a submodule of FLOWFoil containing useful airfoil geometry generation and manipulation routines that are commonly used in the BYU FLOW Lab.","category":"page"},{"location":"AirfoilTools/intro/#Contribution","page":"Intro","title":"Contribution","text":"","category":"section"},{"location":"AirfoilTools/intro/","page":"Intro","title":"Intro","text":"We welcome additional airfoil parameterization methods as well as convenient geometry manipulation routines that make life easier when working with airfoil analysis and optimization.","category":"page"},{"location":"FLOWFoil/examples/#Advanced-Examples:-Verification-and-Validation","page":"Additional Examples","title":"Advanced Examples: Verification and Validation","text":"","category":"section"},{"location":"FLOWFoil/examples/#Mfoil:-Single-inviscid-airfoil-comparision-to-analytic-solution","page":"Additional Examples","title":"Mfoil: Single inviscid airfoil comparision to analytic solution","text":"","category":"section"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"using FLOWFoil\n\ncenter = [-0.1; 0.1]\nradius = 1.0\nalpha = 4.0\nVinf = 1.0\n\n# - Joukowsky Geometry - #\nx, y = FLOWFoil.AirfoilTools.joukowsky(center, radius, N=161)\n\n# - Analytic Solution - #\nsurface_velocity, surface_pressure_coefficient, cl = FLOWFoil.AirfoilTools.joukowsky_flow(\n    center, radius, alpha, Vinf, N=161\n)\n\n# - FLOWFoil Solution - #\noutputs = analyze([x y], alpha; method=Mfoil())\n\ninclude(\"../assets/plots_default.jl\") #hide\npl = plot(; xlabel=L\"x\", ylabel=L\"c_p\", yflip=true) # hide\nplot!( # hide\n    pl, # hide\n    x[2:end-1], # hide\n    surface_pressure_coefficient[2:end-1]; # hide\n    linestyle=:dash, # hide\n    linewidth=2, # hide\n    label=\"Analytic Solution\", # hide\n) # hide\n\nplot!(pl, x[2:end-1], outputs.cp[2:end-1], label=\"Mfoil\") # hide","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"","category":"page"},{"location":"FLOWFoil/examples/#Axisymmetric-Body-of-Revolution","page":"Additional Examples","title":"Axisymmetric Body of Revolution","text":"","category":"section"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"For this example, we use data from chapter 4 of \"Vortex Element Methods for fluid Dynamic Analysis of Engineering Systems\" by  R. I. Lewis","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"using FLOWFoil\n\ndata_path = normpath(\n    joinpath(\n        splitdir(pathof(FLOWFoil))[1], \"..\", \"test\", \"data\", \"bodyofrevolutioncoords.jl\"\n    ),\n)\ninclude(data_path)\n\noutputs = analyze(center_body_coordinates, [0.0]; method=Lewis(; body_of_revolution=[true]))\n\n# plot # hide\ninclude(\"../assets/plots_default.jl\") #hide\nplot(Vs_over_Vinf_x, Vs_over_Vinf_vs, seriestype=:scatter, label=\"Experimental Data\",markerstrokecolor=1, markercolor=1, markersize=4, xlabel=L\"\\frac{x}{c}\", ylabel=L\"\\frac{V_s}{V_\\infty}\", legend=:bottomright) #hide\nplot!(0.5*(center_body_coordinates[1:end-1,1].+center_body_coordinates[2:end,1]), outputs.vs, label=\"FLOWFoil\") #hide","category":"page"},{"location":"FLOWFoil/examples/#Axisymmetric-Annular-Airfoil-(Duct)","page":"Additional Examples","title":"Axisymmetric Annular Airfoil (Duct)","text":"","category":"section"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"If we define an airfoil shape in an axisymmetric scheme, we model an annular airfoil, or in other words, a duct.  To do so, we follow a similar procedure to bodies of revolution with the exception that we set body_of_revolution=false.","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"using FLOWFoil\n\nduct_path = normpath(\n    joinpath(splitdir(pathof(FLOWFoil))[1], \"..\", \"test\", \"data\", \"naca_662-015.jl\")\n)\ninclude(duct_path)\n\noutputs = analyze(duct_coordinates, [0.0]; method=Lewis(; body_of_revolution=[false]))\n\n# plot # hide\ninclude(\"../assets/plots_default.jl\") #hide\nplot(pressurexupper, pressureupper, seriestype=:scatter, markershape=:utriangle, label=\"Experimental Nacelle\", color=1, yflip=true, markerstrokecolor=1, markercolor=1, markersize=4, xlabel=L\"\\frac{x}{c}\", ylabel=L\"c_p\", legend=:bottomright) #hide\nplot!(pressurexlower, pressurelower, seriestype=:scatter, markershape=:dtriangle, label=\"Experimental Casing\", color=1, markerstrokecolor=1, markercolor=1, markersize=4) #hide\nplot!(0.5*(duct_coordinates[1:end-1,1].+duct_coordinates[2:end,1]), outputs.cp, label=\"FLOWFoil\",color=2) #hide","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"As above, we plot experimental results along with our calculated values.","category":"page"},{"location":"FLOWFoil/examples/#Axisymmetric-Mutli-element-Systems","page":"Additional Examples","title":"Axisymmetric Mutli-element Systems","text":"","category":"section"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"As an example of an multi-element axisymmetric system (such as that used for a ducted rotor), we will simply combine the two previous cases. Note that we include the coordinates for the various bodies as a tuple of matrices, and in this case, we need to indicate in the Lewis method fields which of the bodies is a body of revolution (currently, the method only works if the annular airfoil comes first).","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"using FLOWFoil\n\noutputs = analyze(\n    (duct_coordinates, center_body_coordinates), [0.0];\n    method=Lewis(; body_of_revolution=[false, true]),\n)\n\n# plot v # hide\n\nplot(Vs_over_Vinf_x, Vs_over_Vinf_vs, seriestype=:scatter, label=\"Experimental Center Body\",markerstrokecolor=1, markercolor=1, markersize=4, xlabel=L\"\\frac{x}{c}\", ylabel=L\"\\frac{V_s}{V_\\infty}\", legend=:bottomright) #hide\nplot!(0.5*(center_body_coordinates[1:end-1,1].+center_body_coordinates[2:end,1]), outputs.vs[2], label=\"FLOWFoil Center Body with Duct Effects\") #hide","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"# plot cp # hide\n\nplot(pressurexupper, pressureupper, seriestype=:scatter, markershape=:utriangle, label=\"Experimental Nacelle\", color=1, yflip=true, markerstrokecolor=1, markercolor=1, markersize=4, xlabel=L\"\\frac{x}{c}\", ylabel=L\"c_p\", legend=:bottomright) #hide\nplot!(pressurexlower, pressurelower, seriestype=:scatter, markershape=:dtriangle, label=\"Experimental Casing\", color=1, markerstrokecolor=1, markercolor=1, markersize=4) #hide\nplot!(0.5*(duct_coordinates[1:end-1,1].+duct_coordinates[2:end,1]), outputs.cp[1], label=\"FLOWFoil Duct with Center Body Effects\",color=2) #hide","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"Plotting the geometry and the output velocities and pressures show expected behavior when combining these two cases.","category":"page"},{"location":"FLOWFoil/examples/#Airfoil-Cascade","page":"Additional Examples","title":"Airfoil Cascade","text":"","category":"section"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"For this example, we use data from chapter 2 of \"Vortex Element Methods for fluid Dynamic Analysis of Engineering Systems\" by  R. I. Lewis","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"using FLOWFoil\n\n#this file contains the coordinates of the C4/70C50 airfoil as defined by lewis as well as the values of the pressure coefficient\ndata_path = normpath(\n    joinpath(\n        splitdir(pathof(FLOWFoil))[1], \"..\", \"test\", \"data\", \"chapter2_lewis_validation.jl\"\n    ),\n)\ninclude(data_path)\n\n#previously defined coordinates in chapter2_lewis_validation.jl\ncoordinates = [x y]\n\n#setup Martensen method\nmethod = Martensen(; solidity=1.0 / 0.900364, stagger=0.0)\n\n#define flow angles (angles of attack) - in this case the angles of attack = the inflow angles hence why stagger is 0\nflow_angles = [-35.0, 35.0]\n\n#solve for outputs\noutputs = analyze(coordinates, flow_angles; method=method)\n\n# Panel midpoints (x has 51 nodes → 50 panels) # hide\nxmid = 0.5 .* (x[1:end-1] .+ x[2:end]) #hide\n\ninclude(\"../assets/plots_default.jl\") #hide\n# Plot Cp at angle 1 (e.g. -35 degrees) #hide\nscatter(x_from_web_plot_digitizer_negative_35_degrees, cp_Lewis_negative_35_degrees, xlabel=L\"\\frac{x}{c}\", ylabel=L\"c_p\", label=\"Lewis: -35°\", color=1, markerstrokewidth=0, yflip=true, markersize=4, legend=:topright) #hide\nplot!(xmid, outputs.cp[:, 1], label=\"FLOWFoil\", color=2) #hide\n","category":"page"},{"location":"FLOWFoil/examples/","page":"Additional Examples","title":"Additional Examples","text":"scatter(x_from_web_plot_digitizer_positive_35_degrees, cp_Lewis_positive_35_degrees, xlabel=L\"{x}{c}\", ylabel=L\"c_p\", label=\"Lewis: +35°\", color=1, markerstrokewidth=0, yflip=true, markersize=4, legend=:topright) #hide\nplot!(xmid, outputs.cp[:, 2], label=\"FLOWFoil\", color=2) #hide","category":"page"},{"location":"FLOWFoil/private_api/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"FLOWFoil/private_api/#Universal-Dispatch","page":"Private API","title":"Universal Dispatch","text":"","category":"section"},{"location":"FLOWFoil/private_api/","page":"Private API","title":"Private API","text":"These functions are universally called in the convenience function, analyze except for the NeuralFoil and LegacyXfoil methods, which bypass these functions in favor of simply calling those packages' analysis functions.","category":"page"},{"location":"FLOWFoil/private_api/#FLOWFoil.reformat_inputs","page":"Private API","title":"FLOWFoil.reformat_inputs","text":"reformat_inputs(x, y, flow_angle)\nreformat_inputs(coordinates, flow_angle)\n\nReformats inputs to be the expected format.\n\nArguments\n\ncoordinates::Tuple{Matrix{Float}} : Tuple of [x y] matrices of airfoil coordinates (may be a vecotr of matrices as well)\nflow_angle::Vector{Float} : Vector of angles of attack (may be a single float as well)\n\nReturns\n\ncoordinates::Vector{Float} : reformatted coordinates\nnbody::Int : number of bodies\naoa::Vector{Float} : reformatted angles of attack\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.generate_panel_geometry","page":"Private API","title":"FLOWFoil.generate_panel_geometry","text":"generate_panel_geometry(method::Mfoil, coordinates)\n\nGenerates panel geometries for multiple airfoils by broadcasting over a collection of coordinate sets.\n\nArguments\n\nmethod::Mfoil: The Mfoil method configuration object.\ncoordinates: A collection (e.g. vector) of coordinate matrices, each representing airfoil node coordinates.\n\nReturns\n\nA concatenated vector of panel geometry objects for all provided airfoils.\n\n\n\n\n\ngenerate_panel_geometry(method::Mfoil, coordinates::Matrix{TF}) where {TF}\n\nGenerates the panel geometry for a single airfoil given node coordinates.\n\nArguments\n\nmethod::Mfoil: The Mfoil method configuration object.\ncoordinates::Matrix{TF}: Nx2 matrix containing the x and y coordinates of the airfoil nodes, where N is the number of nodes.\n\nReturns\n\nNamed tuple panel_geometry containing:\nnpanels::Int: Number of panels (nodes - 1).\npanel_edges::Array{TF, 3}: An (npanels, 2, 2) array containing the start and end points of each panel.\npanel_vectors::Array{TF, 2}: An (npanels, 2) array of vectors describing panel directions.\npanel_lengths::Array{TF}: Vector of panel lengths.\nnodes::Array{TF, 2}: Array of node coordinates (npanels + 1, 2).\n\n\n\n\n\ngenerate_panel_geometry(method::Lewis, coordinates::AbstractVector)\n\nGenerates panel geometries for multiple airfoil surfaces using the Lewis method.\n\nArguments\n\nmethod::Lewis: Configuration or marker for the Lewis panel method.\ncoordinates::AbstractVector{<:Matrix{<:Real}}: A vector of 2D coordinate matrices, each of size (N+1, 2), defining the panel endpoints for each airfoil surface.\n\nReturns\n\nVector{NamedTuple}: A vector of named tuples, each representing the panel geometry for one airfoil. Each tuple includes:\nnpanels::Int: Number of panels.\npanel_center::Matrix: Midpoints of each panel.\npanel_length::Vector: Lengths of each panel.\npanel_normal::Matrix: Unit normal vectors to each panel.\npanel_curvature::Vector: Curvature of each panel.\npanel_angle::Vector: Angle of each panel with respect to the x-axis (in radians).\n\n\n\n\n\ngenerate_panel_geometry(method::Lewis, coordinates::Matrix{<:Real})\n\nGenerates panel geometry for a single airfoil surface using the Lewis method.\n\nArguments\n\nmethod::Lewis: Configuration or marker for the Lewis panel method.\ncoordinates::Matrix{<:Real}: A matrix of size (N+1, 2), where each row is an (x, r) coordinate of a panel corner. The second column must be non-negative (r ≥ 0), corresponding to the radial direction in axisymmetric flow.\n\nReturns\n\nNamedTuple: A named tuple containing panel geometry fields:\nnpanels::Int: Number of panels.\npanel_center::Matrix: Midpoints of each panel.\npanel_length::Vector: Lengths of each panel.\npanel_normal::Matrix: Unit normal vectors for each panel.\npanel_curvature::Vector: Curvature at each panel.\npanel_angle::Vector: Panel orientation angles (in radians).\n\n\n\n\n\ngenerate_panel_geometry(method::Martensen, coordinates)\n\nBroadcasts generate_panel_geometry! over multiple sets of coordinates to generate panel geometries for multiple airfoils.\n\nArguments\n\nmethod::Martensen: The panel method type.\ncoordinates: A collection (e.g., vector) of coordinate matrices, where each matrix defines the vertices of one airfoil.\n\nReturns\n\nA collection of updated panel_geometry objects corresponding to each set of input coordinates.\n\n\n\n\n\ngenerate_panel_geometry(method::HessSmith, coordinates)\n\nGenerates panel geometry for an airfoil surface to be used in a Hess-Smith panel method.\n\nArguments\n\nmethod::HessSmith: A marker or configuration type representing the Hess-Smith method.\ncoordinates: Either a single Matrix{<:Real} of size (N+1, 2), where each row is an (x, y) coordinate of a panel corner, or an array of such matrices (to process multiple airfoils).\n\nReturns\n\npanel_geometry::NamedTuple: A named tuple containing:\nnpanels::Int: Number of panels.\nx::Vector: x-coordinates of panel endpoints.\ny::Vector: y-coordinates of panel endpoints.\npanel_center::Matrix: Midpoints of each panel.\npanel_length::Vector: Lengths of each panel.\npanel_angle::Vector: Angles (in degrees) of each panel relative to the x-axis.\npanel_vectors::Matrix: Tangent vectors for each panel.\nsine_vector::Vector: Sine of panel orientation angles.\ncosine_vector::Vector: Cosine of panel orientation angles.\n\n\n\n\n\ngenerate_panel_geometry(p, coordinates)\n\nGenerate panel geometries for a given set of coordinates.\n\nArguments:\n\nmethod::Method : method for solving\ncoordinates::Vector{Matrix{Float}} : Vector of [x y] matrices of airfoil coordinates (may be a single matrix as well)\n\nReturns:\n\npanel_geometry::Vector{NTuple} : Vector of named tuples (one for each body in the system)\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.generate_system_geometry","page":"Private API","title":"FLOWFoil.generate_system_geometry","text":"generate_system_geometry(method::Mfoil, panel_geometry::AbstractVector; gap_tolerance=1e-10)\n\nConstructs the system geometry for a multi-airfoil panel method simulation. This includes indexing arrays, combined node and panel data, chord lengths, and precomputed influence geometry for each panel and trailing edge panel.\n\nArguments\n\nmethod::Mfoil: The aerodynamic method object (currently unused, but kept for API consistency).\npanel_geometry::AbstractVector: Vector of panel geometry named tuples, one per airfoil/body, containing nodes, panel edges, vectors, lengths, etc.\n\nKeyword Arguments\n\ngap_tolerance: Threshold tolerance to detect blunt (non-sharp) trailing edges, default 1e-10.\n\nReturns\n\nA named tuple system_geometry containing:\nnbodies: Number of bodies/airfoils.\npanel_indices: Vector of panel index ranges for each body.\nnode_indices: Vector of node index ranges for each body.\nnodes: Combined matrix of all nodes for all bodies.\nmesh2panel: Mapping from global mesh index to panel index.\nchord_length: Overall chord length of the system (max trailing edge - min leading edge).\npanel_length: Vector of panel lengths for all panels combined.\nr1, lnr1, r1normal, r1tangent, theta1, r2, lnr2, theta2: Matrices of precomputed influence geometry quantities for all panels on all field points.\nTE_geometry: Named tuple with trailing edge gap panel geometry and related influence parameters:\nblunt_te: Boolean vector indicating blunt trailing edges.\npanel_length: Trailing edge gap lengths.\ntdp, txp: Trailing edge panel parameters.\nr1, lnr1, r1normal, r1tangent, theta1, r2, lnr2, theta2: Influence geometry matrices for trailing edge panels.\n\n\n\n\n\ngenerate_system_geometry(method::Lewis, panel_geometry)\n\nGenerate system geometry for a single airfoil by wrapping it in a vector and calling the vector version of the function.\n\nArguments\n\nmethod::Lewis: Marker type indicating the Lewis method.\npanel_geometry: A single panel geometry object.\n\nReturns\n\nsystem_geometry: A NamedTuple containing system-wide geometric information, suitable for the Lewis method.\n\n\n\n\n\ngenerate_system_geometry(method::Lewis, panel_geometry::AbstractVector)\n\nGenerate the system geometry for multiple bodies (airfoils) for the Lewis method.\n\nArguments\n\nmethod::Lewis: Marker type indicating the Lewis method.\npanel_geometry: Vector of panel geometry objects, each representing one body.\n\nReturns\n\nsystem_geometry::NamedTuple with fields:\nnbodies::Int: Number of bodies.\npanel_indices::Vector{UnitRange}: Index ranges for panels of each body.\nmesh2panel::Vector{Int}: Mapping from mesh indices to panel indices.\nz::Matrix{TF}: Normalized axial (z) distances between panel centers.\nr::Matrix{TF}: Normalized radial (r) distances between panel centers.\nk2::Matrix{TF}: k² values used in elliptic integral calculations.\n\n\n\n\n\ngenerate_system_geometry(method::Martensen, panel_geometry)\n\nGenerates system geometry for a single body by wrapping the vector version.\n\nArguments\n\nmethod::Martensen: The panel method object containing method parameters.\npanel_geometry: Panel geometry object for a single body.\n\nReturns\n\nA system geometry named tuple containing indexing, distance arrays, and pitch.\n\n\n\n\n\ngenerate_system_geometry(method::Martensen, panel_geometry::AbstractVector)\n\nGenerates system geometry data for one or more bodies in a panel method simulation.\n\nArguments\n\nmethod::Martensen: The panel method object containing parameters like solidity.\npanel_geometry::AbstractVector: Vector of panel geometry objects, one per body.\n\nReturns\n\nA named tuple containing:\nnbodies: Number of bodies.\npanel_indices: Vector of ranges indexing each body's panels within the global panel mesh.\nmesh2panel: Vector mapping mesh indices to panel indices.\nr_x, r_y: Matrices containing x and y distances between panel centers.\nr_squared: Matrix of squared distances.\npitch: Characteristic pitch length for cascade geometry.\n\n\n\n\n\ngenerate_system_geometry(method::HessSmith, panel_geometry)\n\nWrapper function that constructs the full system geometry for the Hess-Smith panel method, accepting a single panel_geometry object (e.g., from generate_panel_geometry). Internally wraps the single input into a vector and delegates to the more general method.\n\nArguments\n\nmethod::HessSmith: The Hess-Smith solver object.\npanel_geometry: A named tuple returned from generate_panel_geometry\n\nReturns\n\nsystem_geometry: A named tuple with computed geometric data required for panel-panel influence calculations.\n\n\n\n\n\ngenerate_system_geometry(method::HessSmith, panel_geometry::AbstractVector)\n\nComputes the system-level geometric data required by the Hess-Smith method for one or more bodies, based on their respective panel geometries. This includes angular differences between panels, distances from control points to panel nodes, and orientation metrics for influence calculations.\n\nArguments\n\nmethod::HessSmith: The Hess-Smith solver object.\npanel_geometry::AbstractVector: A vector of named tuples, each representing the panel geometry of a single body, as returned by generate_panel_geometry.\n\nReturns\n\nsystem_geometry::NamedTuple containing:\nnbodies::Int: Number of bodies in the system.\npanel_indices::Vector{UnitRange}: Index ranges for each body’s panels in the full mesh.\nmesh2panel::Vector{Int}: Mapping from system mesh index to panel index per body.\nsine_angle_panels::Matrix: Sine of angle difference between panel pairs.\ncos_angle_panels::Matrix: Cosine of angle difference between panel pairs.\nbeta::Matrix: Panel-to-panel angular influence terms.\nr_x::Matrix: x-component distances from control points to node points.\nr_y::Matrix: y-component distances from control points to node points.\nr_squared::Matrix: Squared distances from control points to node points.\nr_influence::Matrix: Euclidean distances from control points to node points.\nchord_length::Vector: Chord length of each body.\n\n\n\n\n\ngenerate_system_geometry(method::Method, panel_geometry; gap_tolerance=1e-10) end\n\nGenerate relative geometry between panels used in assembling the system matrices.\n\nArguments:\n\nmethod::Method : Problem type object for dispatch\npanel_geometry::Vector{Panel} : Array of panel object for airfoil system. (can also be a single panel object if only one body is being modeled)\n\nReturns:\n\nsystem_goemetry::NTuple : Named tuple including various influence geometries for the system\nTE_geometry::NTuple : Named tuple specifically for trailing edge gap panel_geometry if present.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.generate_system_matrices","page":"Private API","title":"FLOWFoil.generate_system_matrices","text":"generate_system_matrices(method::Mfoil, panel_geometry, system_geometry)\n\nConstructs the linear system matrices for the panel method aerodynamic problem.\n\nArguments\n\nmethod::Mfoil: The aerodynamic method object defining the solution approach.\npanel_geometry: Geometry data for the airfoil panels (unused directly here but available for extensions).\nsystem_geometry: Precomputed system geometry containing panel and node indices and influence parameters.\n\nReturns\n\nNamed tuple with:\nA: The coefficient matrix (influence matrix) representing panel interactions.\nb: The boundary conditions vector representing the RHS of the linear system.\nnode_indices: The node indexing ranges for each body in the system.\n\n\n\n\n\ngenerate_system_matrices(method::Lewis, panel_geometry, system_geometry)\n\nGenerate the system matrices (coefficient matrix A and right-hand side vector b) for the Lewis method given panel geometry and system geometry.\n\nArguments\n\nmethod::Lewis: Marker type indicating the Lewis method.\npanel_geometry: A single panel geometry object.\nsystem_geometry: System geometry NamedTuple containing relative panel positions.\n\nReturns\n\nNamedTuple with fields:\nA::Matrix{Float}: Coefficient matrix of the linear system.\nb::Vector{Float}: Right-hand side vector for boundary conditions.\n\n\n\n\n\ngenerate_system_matrices(method::Lewis, panel_geometry::AbstractVector, system_geometry)\n\nGenerate the system matrices (coefficient matrix A and right-hand side vector b) for multiple bodies using the Lewis method.\n\nArguments\n\nmethod::Lewis: Marker type indicating the Lewis method.\npanel_geometry::Vector{Panel}: Vector of panel geometry objects for each body.\nsystem_geometry: System geometry NamedTuple containing relative panel positions.\n\nReturns\n\nNamedTuple with fields:\nA::Matrix{Float}: Coefficient matrix of the linear system.\nb::Vector{Float}: Right-hand side vector for boundary conditions.\n\n\n\n\n\ngenerate_system_matrices(method::Martensen, panel_geometry, system_geometry)\n\nConvenience method to generate system matrices for a single panel geometry body.\n\nArguments\n\nmethod::Martensen: The Martensen method configuration object.\npanel_geometry: A single panel geometry object representing one body.\nsystem_geometry: Precomputed system geometry object for the panels.\n\nReturns\n\nNamed tuple containing:\nA: Coefficient matrix of the system.\nb: Boundary condition vector (right-hand side).\n\n\n\n\n\ngenerate_system_matrices(method::Martensen, panel_geometry::AbstractVector, system_geometry)\n\nGenerates the linear system matrices for multiple panel geometry bodies based on the Martensen method.\n\nArguments\n\nmethod::Martensen: The Martensen method configuration object containing method parameters.\npanel_geometry::AbstractVector: Vector of panel geometry objects, one for each body.\nsystem_geometry: Precomputed system geometry object describing relative panel positions and distances.\n\nReturns\n\nNamed tuple containing:\nA: Coefficient matrix for the linear system.\nb: Boundary condition vector (right-hand side).\n\n\n\n\n\ngenerate_system_matrices(method::HessSmith, panel_geometry, system_geometry)\n\nWrapper function to generate the Hess-Smith system matrices for a single body. Internally wraps the panel geometry into a vector and delegates to the general multi-body function.\n\nArguments\n\nmethod::HessSmith: The solver object or configuration struct for the Hess-Smith panel method.\npanel_geometry: A named tuple representing a single body's panel geometry (e.g., from generate_panel_geometry).\nsystem_geometry: A named tuple containing geometric data between panels (e.g., from generate_system_geometry).\n\nReturns\n\nA named tuple (; A, b) where:\nA::Matrix: The system matrix representing the vortex influence coefficients (LHS of linear system).\nb::Vector: The boundary condition vector (RHS of linear system).\n\n\n\n\n\ngenerate_system_matrices(method::HessSmith, panel_geometry::AbstractVector, system_geometry)\n\nGenerates the system matrices for solving the Hess-Smith panel method. This includes the vortex influence coefficient matrix (A) and the boundary condition vector (b), for one or more bodies.\n\nArguments\n\nmethod::HessSmith: The solver object or configuration struct for the Hess-Smith panel method.\npanel_geometry::AbstractVector: A vector of named tuples representing the panel geometry of each body.\nsystem_geometry: A named tuple containing system-level geometric data (from generate_system_geometry).\n\nReturns\n\nA named tuple (; A, b) where:\nA::Matrix: The system matrix of vortex influence coefficients.\nb::Vector: The vector of boundary conditions imposed at the control points.\n\n\n\n\n\ngenerate_system_matrices(method::Method, mesh, TEmesh)\n\nAssemble various matrices used in system solves.\n\nArguments:\n\nmethod::Method : method object for dispatch\npanel_geometry::Vector{NTuple} : Vector of named tuples (one for each body in the system)\nsystem_geometry::NTuple : geometry for airfoil system to analyze.\nTE_geometry::NTuple : Trailing edge gap panel influence geometry.\n\nReturns:\n\nsystem::NTuple : Named tuple containing relevant influence and right hand side matrices, etc.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.solve","page":"Private API","title":"FLOWFoil.solve","text":"solve(::Lewis, system_matrices)\n\nSolves the linear system for the Lewis method to find the strengths of singularities on panels.\n\nArguments\n\n::Lewis: Marker type indicating the Lewis method.\nsystem_matrices: A NamedTuple containing:\nA: The coefficient matrix (LHS).\nb: The right-hand side vector or matrix.\n\nReturns\n\nx: The solution vector or matrix containing singularity strengths.\n\n\n\n\n\nsolve(::Martensen, system_matrices)\n\nSolves the linear system for the Lewis method to find the strengths of singularities on panels.\n\nArguments\n\n::Martensen: Marker type indicating the Martensen method.\nsystem_matrices: A NamedTuple containing:\nA: The coefficient matrix (LHS).\nb: The right-hand side vector or matrix.\n\nReturns\n\nx: The solution vector or matrix containing singularity strengths.\n\n\n\n\n\nsolve(::HessSmith, system_matrices)\n\nSolves the linear system A * γ = b arising from the Hess-Smith panel method, where A is the vortex influence matrix and b is the boundary condition vector.\n\nArguments\n\n::HessSmith: The Hess-Smith solver type, used for dispatch.\nsystem_matrices: A named tuple with fields:\nA::Matrix: The system matrix of vortex influence coefficients.\nb::Vector: The boundary condition vector.\n\nReturns\n\nγ::Vector: The solution vector of vortex strengths (circulation values) at each panel.\n\n\n\n\n\nsolve(method::Method, system_matrices)\n\nSolve system.\n\nArguments:\n\nmethod::Method : method object for dispatch\nsystem_matrices::system_matrices : system to solve\n\nReturns:\n\nstrengths:Array{Float} : values for solved panel strengths\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.post_process","page":"Private API","title":"FLOWFoil.post_process","text":"post_process(method::Mfoil, panel_geometry::NamedTuple, system_geometry, strengths, flow_angles; npanels=80)\n\nPost-processes the aerodynamic solution for a single airfoil by wrapping the vector version of post_process.\n\nArguments\n\nmethod::Mfoil: The Mfoil method object (configuration).\npanel_geometry::NamedTuple: Panel geometry data for a single airfoil.\nsystem_geometry: System geometry containing info like panel indices and chord lengths.\nstrengths: Matrix of vortex strengths (rows correspond to nodes/panels, columns to different components).\nflow_angles: Vector of flow angles of attack (in degrees).\n\nKeyword Arguments\n\nnpanels: Number of panels to use for output (default 80).\n\nReturns\n\nAn InviscidOutputs object containing aerodynamic coefficients and surface distributions.\n\n\n\n\n\npost_process(::Mfoil, panel_geometry::AbstractVector, system_geometry, strengths, flow_angles)\n\nComputes aerodynamic surface velocities, pressures, and coefficients (lift, drag, moment) for one or more airfoils over a range of flow angles.\n\nArguments\n\n::Mfoil: Method configuration object (not used directly but required for dispatch).\npanel_geometry::AbstractVector: Vector of panel geometry data, one for each airfoil/body.\nsystem_geometry: System geometry object containing details such as panel and node indices, chord lengths, and mapping arrays.\nstrengths: Matrix containing vortex strengths at nodes for each angle of attack.\nflow_angles: Vector of flow angles of attack in degrees.\n\nReturns\n\nIf one airfoil, returns an InviscidOutputs struct with fields:\nvs: Surface velocity distributions.\ncp: Surface pressure distributions.\ncl: Lift coefficient array (angles × bodies).\ncd: Total drag coefficient array.\ncm: Moment coefficient array.\nIf multiple airfoils, returns an InviscidOutputs struct with surface velocities and pressures as vectors corresponding to each body.\n\n\n\n\n\npost_process(method::Lewis, panel_geometry, system_geometry, strengths, flow_angles; npanels=80)\n\nWrapper function for post-processing a single airfoil geometry using the Lewis method. The flow_angles argument is included for interface compatibility but is unused.\n\nArguments\n\nmethod::Lewis: Lewis method configuration object.\npanel_geometry: A single panel geometry (as a NamedTuple).\nsystem_geometry: Precomputed system geometry object used in the solver.\nstrengths: Vector of strength values returned by the solver.\nflow_angles: Placeholder input; ignored in this function (included for API consistency).\n\nKeyword Arguments\n\nnpanels::Int=80: Number of panels used in the geometry (for reference or optional reshaping).\n\nReturns\n\nInviscidOutputs: A structure containing:\nsurface_velocity::Matrix: Velocity on the surface panels.\nsurface_pressure::Matrix: Pressure coefficient distribution on panels.\ncl::Matrix: Lift coefficient (always zero for axisymmetric bodies).\ncd::Matrix: Drag coefficient (zero; not calculated here).\ncm::Matrix: Moment coefficient (zero; not calculated here).\n\n\n\n\n\npost_process(method::Lewis, panel_geometry::AbstractVector, system_geometry, strengths, flow_angles; npanels=80)\n\nComputes surface velocity and pressure coefficient distributions for multiple airfoil bodies using the Lewis method.\n\nArguments\n\nmethod::Lewis: Lewis method configuration object.\npanel_geometry::AbstractVector: Vector of panel geometry NamedTuples, one for each body.\nsystem_geometry: System geometry used in the Lewis method solution.\nstrengths: Vector of source/vortex strengths computed by the solver.\nflow_angles: Placeholder input; not used in the Lewis implementation (for compatibility only).\n\nKeyword Arguments\n\nnpanels::Int=80: Number of panels (optional; not used internally).\n\nReturns\n\nInviscidOutputs: A structure containing:\nsurface_velocity::Vector{Matrix}: Velocity on surface panels per body.\nsurface_pressure::Vector{Matrix}: Pressure coefficient per panel per body.\ncl::Matrix: Lift coefficient (not calculated; zero-filled).\ncd::Matrix: Drag coefficient (not calculated; zero-filled).\ncm::Matrix: Moment coefficient (not calculated; zero-filled).\n\n\n\n\n\npost_process(method::Martensen, panel_geometry, system_geometry, strengths, flow_angles)\n\nWrapper function to handle single airfoil case by calling the vectorized version.\n\nArguments\n\nmethod::Martensen: The panel method type.\npanel_geometry: Panel geometry object for a single airfoil.\nsystem_geometry: System geometry object containing panel indices, etc.\nstrengths: Vortex strength matrix for the panels.\nflow_angles: Vector of flow angles (degrees) at which to evaluate outputs.\n\nReturns\n\nInviscidOutputs: Struct containing velocity (vs), pressure coefficient (cp), lift (cl), drag (cd), and moment (cm) coefficients.\n\n\n\n\n\npost_process(\n    method::Martensen,\n    panel_geometry::AbstractVector,\n    system_geometry,\n    strengths,\n    flow_angles,\n)\n\nComputes post-processed aerodynamic outputs such as surface velocities, pressure coefficients, and aerodynamic coefficients (lift, drag, moment) for one or multiple airfoils or bodies in a system.\n\nArguments\n\nmethod::Martensen: The panel method type, including options such as cascade.\npanel_geometry::AbstractVector: Vector of panel geometry objects for each body.\nsystem_geometry: System geometry object containing indices and geometric data.\nstrengths: Matrix of vortex strengths for panels (dimensions related to panels and flow angles).\nflow_angles: Vector of flow angles (in degrees) at which to evaluate aerodynamic results.\n\nReturns\n\nInviscidOutputs: Struct containing:\nvs: Surface velocity distributions for each panel and flow angle.\ncp: Pressure coefficients on the surface panels.\ncl: Lift coefficients for each body and flow angle.\ncd: Drag coefficients (currently zero arrays).\ncm: Moment coefficients (currently zero arrays).\n\n\n\n\n\npost_process(method::HessSmith, panel_geometry, system_geometry, strengths, flow_angles)\n\nWrapper function for computing post-processing aerodynamic results when only a single body is used in the panel method formulation. Converts a single-body input into a vector format expected by the full multi-body post_process method, ensuring uniform handling for downstream calculations.\n\nArguments\n\nmethod::HessSmith: The solver type used to dispatch Hess-Smith panel method logic.\npanel_geometry: The panel geometry object for a single body (not a vector).\nsystem_geometry: Geometry-related precomputed fields needed for influence calculations.\nstrengths::Matrix: Matrix of vortex strengths per panel.\nflow_angles::Vector{<:Real}: Array of freestream angles of attack (in degrees).\n\nReturns\n\nAn InviscidOutputs object containing:\nvs: Tangential velocities.\ncp: Pressure coefficients.\ncl: Lift coefficients.\ncd: Drag coefficients (zeroed for inviscid).\ncm: Moment coefficients (zeroed for inviscid).\n\n\n\n\n\npost_process(::HessSmith, panel_geometry, system_geometry, strengths, flow_angles)\n\nComputes tangential velocities, pressure coefficients, and aerodynamic coefficients (lift, drag, and moment) for a given configuration of panels and freestream conditions using the Hess-Smith panel method.\n\nArguments\n\n::HessSmith: Marker type for dispatching the Hess-Smith solver method.\npanel_geometry::AbstractVector: Vector of panel geometry objects, each representing an airfoil or body.\nsystem_geometry: Precomputed system geometry structure (distances, angles, etc.) used for influence calculations.\nstrengths::Matrix: Matrix of vortex strengths for each panel and each vector component.\nflow_angles::Vector{<:Real}: Freestream angles of attack (in degrees) to evaluate aerodynamic performance.\n\nReturns\n\nIf nbodies == 1: An InviscidOutputs struct containing:\nvs: Matrix of tangential velocities for each panel and angle of attack.\ncp: Matrix of surface pressure coefficients.\ncl: Vector of lift coefficients.\ncd: Vector of drag coefficients (currently zero for inviscid flow).\ncm: Vector of moment coefficients (currently zero for inviscid flow).\nIf nbodies > 1: An InviscidOutputs struct containing:\nvs::Vector{Matrix}: List of tangential velocity matrices for each body.\ncp::Vector{Matrix}: List of pressure coefficient matrices for each body.\ncl::Matrix: Matrix of lift coefficients [n_aoa, n_bodies].\ncd::Matrix: Matrix of drag coefficients (zero).\ncm::Matrix: Matrix of moment coefficients (zero).\n\n\n\n\n\npost_process(method::Method, panel_geometry, system_geometry, strengths)\n\nPost-process solution and produce a Polar object.\n\nArguments:\n\nmethod::Method : Problem type for dispatch\npanel_geometry::Vector{Panel} : vector of Panel objects\nsystem_geometry::NTuple : geometry for airfoil system to analyze.\nstrengths:Array{Float} : values for solved panel strengths\n\nReturns:\n\noutputs::Outputs : object of type outputs\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#Universal-Utility-Functions","page":"Private API","title":"Universal Utility Functions","text":"","category":"section"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_d","page":"Private API","title":"FLOWFoil.get_d","text":"get_d(node1, node2)\n\nCalculate panel length (between adjacent nodes).\n\nArguments\n\nnode1::Array{Float}(2) : [x y] location of first node\nnode2::Array{Float}(2) : [x y] location of second node\n\nReturns\n\nd::Vector{Float} : vector from node1 to node2\ndmag::Float : length of panel between node1 and node2\n\n\n\n\n\nget_d(node1, node2)\n\nCalculate panel length (between adjacent nodes).\n\nArguments\n\nnode1::Array{Float}(2) : [x y] location of first node\nnode2::Array{Float}(2) : [x y] location of second node\n\nReturns\n\nd::Vector{Float} : vector from node1 to node2\ndmag::Float : length of panel between node1 and node2\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_r","page":"Private API","title":"FLOWFoil.get_r","text":"function get_r(node,point)\n\nCalculate the vector, mathbfr, and distance, r, from the node to the evaluation point\n\nArguments\n\nnode::Array{Float} : [x y] position of node\npoint::Array{Float} : [x y] position of point.\n\nReturns\n\nr::Vector{Float} : vector from node to evaluation point\nrmag::Float : length of panel between node and evaluation point\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_panel_tangent","page":"Private API","title":"FLOWFoil.get_panel_tangent","text":"get_panel_tangent(d, dmag)\n\nGet unit tangent to panel.\n\nArguments\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_panel_normal","page":"Private API","title":"FLOWFoil.get_panel_normal","text":"get_panel_normal(d, dmag)\n\nGet unit normal to panel.\n\nArguments\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.calculate_chord","page":"Private API","title":"FLOWFoil.calculate_chord","text":"calculate_chord(panel_geometry)\n\nCalculate the chord length of an airfoil system based on panel geometry.\n\nArguments\n\npanel_geometry::AbstractVector: A vector of panel geometry objects. Each object is expected to have a field panel_center containing the (x, y) coordinates of panel centers.\n\nReturns\n\nFloat64: The chord length, defined as the difference between the maximum and minimum x-coordinates of the panel centers across all airfoil bodies.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.linear_transform","page":"Private API","title":"FLOWFoil.linear_transform","text":"linear_transform(range1, range2, values)\n\nLinear transfrom of values from range (sourcerange[1], raend) to (targetrange[1], target_range[end])\n\nArguments\n\nsource_range::Vector{Float{ : range values come from\ntarget_range::Vector{Float} : range onto which we are transforming\nsource_values::Array{Float} : array of source_values to transform\n\nReturns\n\ntarget_values::Array{Float} : array of transformed source_values onto target range\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.smooth_distributions","page":"Private API","title":"FLOWFoil.smooth_distributions","text":"smooth_distributions(method, panel_geometry, surface_values, npoints)\n\nGenerates smooth surface distribution values.\n\nArguments\n\npanel_geometry::NamedTuple : NamedTuple that comes from generate_panel_geometry. Must contain panel_edges.\ndistribution::Array{Float} : surface distribution values\nnpoints::Int : Total number of points in the new distribution covering the entire airfoil. (There will be (npoints+1)/2 points on the top and bottom surfaces, respectively.)\n\nReturns\n\ndistribution::Vector{Float} : Smoothed surface distribution\nxsmooth::Vector{Float} : Smoothed x-coordinates\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.dot","page":"Private API","title":"FLOWFoil.dot","text":"dot(A, B) = sum(a * b for (a, b) in zip(A, B))\n\nA faster dot product.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.smooth_beta","page":"Private API","title":"FLOWFoil.smooth_beta","text":"smooth_beta(mach; blend_range=0.02)\n\nCompute a smoothened compressibility correction factor β based on Mach number.\n\nArguments\n\nmach::Float: Mach number (flow speed / speed of sound).\nblend_range::Float=0.02: Range near the cutoff Mach number (default 0.02) over which to blend corrections smoothly.\n\nReturns\n\nbeta::Float: Smoothed value of β used in compressibility corrections, transitioning near Mach 1.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#FLOWFoil.laitone_compressibility_correction","page":"Private API","title":"FLOWFoil.laitone_compressibility_correction","text":"laitone_compressibility_correction(coeff, mach; gamma=1.4)\n\nApply Laitone's compressibility correction to a coefficient at given Mach number.\n\nArguments\n\ncoeff::Float: Original coefficient (e.g., lift coefficient) to be corrected.\nmach::Float: Mach number of the flow.\ngamma::Float=1.4: Ratio of specific heats (default is 1.4 for air).\n\nReturns\n\ncl::Float: Corrected coefficient accounting for compressibility effects.\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/private_api/#Additional-Method-Utilities","page":"Private API","title":"Additional Method Utilities","text":"","category":"section"},{"location":"FLOWFoil/private_api/#Lewis","page":"Private API","title":"Lewis","text":"","category":"section"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_relative_geometry_axisym-Tuple{Any, Any}","page":"Private API","title":"FLOWFoil.get_relative_geometry_axisym","text":"get_relative_geometry_axisym(panel, field_point)\n\nObtain relevant geometry associated with ring singularity influence calculations for arbitrary field point\n\nArguments\n\npanel::FLOWFoil.AxiSymPanel : the jth panel (the panel doing the influencing).\nfield_point::Array{Float} : [x;r] coordinates of the field point in question.\n\nReturns\n\nx::Float : ratio of difference of ith and jth panel x-locations and jth panel r-location ( (xi-xj)/rj )\nr::Float : ratio of r-locations of ith and jth panels (ri/rj)\nrj::Float : r-location of the jth panel control point\ndmagj::Float : length of the jth panel\nm::Float : Elliptic Function parameter\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_ring_geometry-Tuple{Any, Any}","page":"Private API","title":"FLOWFoil.get_ring_geometry","text":"get_ring_geometry(paneli, panelj)\n\nObtain relevant geometry associated with ring singularity influence calculations.\n\nArguments\n\npaneli::FLOWFoil.AxiSymPanel : the ith panel (the panel being influenced).\npanelj::FLOWFoil.AxiSymPanel : the jth panel (the panel doing the influencing).\n\nReturns\n\nx::Float : ratio of difference of ith and jth panel x-locations and jth panel r-location ( (xi-xj)/rj )\nr::Float : ratio of r-locations of ith and jth panels (ri/rj)\nrj::Float : r-location of the jth panel control point\ndmagj::Float : length of the jth panel\nm::Float : Elliptic Function parameter\nnhati::Array{Float} : unit normal vector of ith panel\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#Mfoil","page":"Private API","title":"Mfoil","text":"","category":"section"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_r_normal-Tuple{Any, Any, Any}","page":"Private API","title":"FLOWFoil.get_r_normal","text":"get_r_normal(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel normal direction.\n\nArguments\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_r_tangent-Tuple{Any, Any, Any}","page":"Private API","title":"FLOWFoil.get_r_tangent","text":"get_r_tangent(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel tangent direction.\n\nArguments\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_theta-Tuple{Any, Any}","page":"Private API","title":"FLOWFoil.get_theta","text":"get_theta(h, a)\n\nGet angle (in radians) between panel and vector from node1 to evaluation point.\n\nArguments\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_theta2-Tuple{Any, Any, Any}","page":"Private API","title":"FLOWFoil.get_theta2","text":"get_theta2(h, a, dmag)\n\nGet angle (in radians) between panel and vector from node2 to evaluation point.\n\nArguments\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\ndmag::Float : Panel lentgh.\n\n\n\n\n\n","category":"method"},{"location":"FLOWFoil/private_api/#FLOWFoil.get_trailing_edge_info-Tuple{Any}","page":"Private API","title":"FLOWFoil.get_trailing_edge_info","text":"get_trailing_edge_info(nodes)\n\nCalculate various items needed for trailing edge treatment.\n\nArguments\n\nnodes::Array{Float,2} : Array of [x y] locations for the airfoil nodes.\n\nReturns\n\ntdp::Float : dot product of TE bisection and TE gap unit vectors\ntxp::Float : \"cross product\" of TE bisection and TE gap unit vectors\ntrailing_edge_gap::Float : TE gap distance\ngap_edges\ndte\ndtemag\n\n\n\n\n\n","category":"method"},{"location":"#FLOWFoil.jl-([Fl]()ight,-[O]()ptimization,-and-[W]()ind-Air[Foil]()-Analysis)","page":"Home","title":"FLOWFoil.jl (Flight, Optimization, and Wind AirFoil Analysis)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Build Status) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"FLOWFoil is a collection of two dimensional potential flow solvers (panel methods) for airfoils, airfoil systems, and axisymmetric sections/systems. The following table includes the list of currently available methods (usage can be found in the docs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Type Multi-body Compatible AD Compatible (ForwardDiff.jl) References or Wrapped Pacakge\nMfoil Inviscid, linear vortex 🚧 (example under development) ✅ 1, 2\nLewis Inviscid, axisymmetric, constant vortex ✅ ✅ 3\nMartensen Inviscid, periodic, constant vortex 🚧 (needs test case) ✅ 3\nHessSmith Inviscid, constant source, single vortex 🚧 (to be added) ✅ 4\nLegacyXfoil Wrapper for Xfoil.jl ❌ ❌ Xfoil.jl\nNeuralFoil Wrapper for NeuralFoil.jl ❌ ✅ NeuralFoil.jl","category":"page"},{"location":"#References:","page":"Home","title":"References:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fidkowski, K. J., \"A Coupled Inviscid-Viscous Airfoil Analysis Solver, Revisited,\" AIAA Journal, 2021.\nDrela, M., \"XFOIL: An Analysis and Design System for Low Reynolds Number Airfoils,\" 1989.\nR. I. Lewis, \"Vortex Element Methods for fluid Dynamic Analysis of Engineering Systems,\" 1991\nNing, A. \"Computational Aerodynamics,\" 2022","category":"page"},{"location":"FLOWFoil/tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"FLOWFoil/tutorial/","page":"Quick Start","title":"Quick Start","text":"Running FLOWFoil can be done simply with a single method: analyze","category":"page"},{"location":"FLOWFoil/tutorial/#FLOWFoil.analyze","page":"Quick Start","title":"FLOWFoil.analyze","text":"analyze(coordinates, flow_angles=0.0, reynolds=1e6, mach=0.0; method::Method=Mfoil())\nanalyze(x, y, flow_angles=0.0, reynolds=1e6, mach=0.0; method::Method=Mfoil())\n\nConvenience function for setting up, solving, and post-processing airfoils and airfoil systems.\n\nArguments\n\ncoordinates::NTuple{Matrix{Float}} : Tuple of [x y] matrices of airfoil coordinates (may be a single matrix as well)\nflow_angles::Vector{Float} : Vector of angles of attack (may be a single float as well)\n\nOR\n\nx::Vector{Float} : Vector of x-coordinates of airfoil geometry\ny::Vector{Float} : Vector of y-coordinates of airfoil geometry\nflow_angles::Vector{Float} : Vector of angles of attack (may be a single float as well)\n\nNote that inputting separate vectors for airfoil coordinates is only available for analysis of single airfoils/bodies.  Multi-airfoil/body systems require the use of a tuple of matrices for coordinate inputs.\n\nKeyword Arguments\n\nmethod::MethodType : desired method for solving\n\nReturns\n\noutputs::OutputType : outputs object (note that only inviscid methods are currently implemented)\n\n\n\n\n\n","category":"function"},{"location":"FLOWFoil/tutorial/","page":"Quick Start","title":"Quick Start","text":"As an introductory example, we will do a quick analysis of a NACA 2412 airfoil, with coordinates from one of the available methods in the Airfoil Tools sub-module.","category":"page"},{"location":"FLOWFoil/tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nFor any airfoil coordinate generation method (from FLOWFoil or otherwise), the coordinates must start at the trailing edge, and proceed clockwise around the airfoil. For axisymmetric bodies of revolution, coordiantes should also proceed clockwise, starting at the leading edge.","category":"page"},{"location":"FLOWFoil/tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFoil\n\n# note: 2412 is default for the NACA 4-series implemenation\nx, y = AirfoilTools.naca4()\n\n# choose one or more angles of attack\nangles_of_attack = range(-5.0, 15.0, step=1)\n\n# analyze\noutputs = analyze(x, y, angles_of_attack)","category":"page"}]
}
