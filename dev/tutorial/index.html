<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · FLOWFoil.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://flow.byu.edu/FLOWFoil.jl/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLOWFoil.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLOWFoil.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Intro</a></li><li class="is-active"><a class="tocitem" href>Quick Start</a><ul class="internal"><li><a class="tocitem" href="#Single-Airfoil-Inviscid-Solution"><span>Single Airfoil Inviscid Solution</span></a></li><li><a class="tocitem" href="#Multiple-Airfoil-Inviscid-Solution"><span>Multiple Airfoil Inviscid Solution</span></a></li><li><a class="tocitem" href="#Axisymmetric-Body-of-Revolution"><span>Axisymmetric Body of Revolution</span></a></li><li><a class="tocitem" href="#Axisymmetric-Annular-Airfoil-(Duct)"><span>Axisymmetric Annular Airfoil (Duct)</span></a></li><li><a class="tocitem" href="#Axisymmetric-Mutli-element-Systems"><span>Axisymmetric Mutli-element Systems</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Guided Examples</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/master/docs/src/tutorial.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>FLOWFoil is structured as follows:</p><ul><li>The user generates a <code>Problem</code>.</li><li>The <code>Problem</code> is solved, generating a <code>Solution</code>.</li><li>The <code>Solution</code> is post-processed, generating a <code>Polar</code>.</li></ul><p>There are also some included convenience functions for geometry generation and manipulation.</p><hr/><h2 id="Single-Airfoil-Inviscid-Solution"><a class="docs-heading-anchor" href="#Single-Airfoil-Inviscid-Solution">Single Airfoil Inviscid Solution</a><a id="Single-Airfoil-Inviscid-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Airfoil-Inviscid-Solution" title="Permalink"></a></h2><p>Let&#39;s first look at the simplest case, a single inviscid airfoil. We&#39;ll first set up the geometry, then define the problem, then solve the problem, then post process it, and finally plot some of the outputs.</p><h4 id="Geometry-Definition"><a class="docs-heading-anchor" href="#Geometry-Definition">Geometry Definition</a><a id="Geometry-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-Definition" title="Permalink"></a></h4><p>For this example, we&#39;ll use one of the airfoil parameterization convenience functions to generate the x,z coordinates of an arbitrary Joukowsky airfoil. FLOWFoil includes several such convenience functions, which you can find more information on the <a href="../reference/#API-Reference">API Reference</a> page.</p><pre><code class="language-julia hljs">## -- SET UP GEOMETRY

# arbitrarily pick some joukowsky airfoil parameters
center = [-0.1; 0.1]
radius = 1.0
num_nodes = 160

# get airfoil coordinates for joukowsky airfoil
x, z = FLOWFoil.joukowsky(center, radius; N=num_nodes)

# get analytic joukowsky solution for later, using alpha=4 and vinf = 1.0
vj, cpj, clj = FLOWFoil.joukowskyflow(center, radius, 4.0, 1.0; N=num_nodes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-1.3769037493948, -0.873450143670928, -0.8652072784119402, -0.8573694771536258, -0.8499451808850679, -0.8429421011686561, -0.8363672000800074, -0.8302266707653558, -0.8245259185818251, -0.8192695427776406  …  0.9758222419438082, 0.964137788561169, 0.9527387620786106, 0.9416396466944831, 0.9308544348983546, 0.9203966006480911, 0.9102790732038729, 0.9005142116328577, 0.8911137799952931, NaN], [-0.8958639350974582, 0.2370848465212353, 0.2514163653830034, 0.26491757964531837, 0.27759318949024925, 0.2894486140773712, 0.3004899066303288, 0.3107236751498734, 0.3201570095867975, 0.3287974162769156  …  0.04777095212775995, 0.07043832466837852, 0.09228885123291652, 0.11331477577308913, 0.13351002103006493, 0.15287009751543823, 0.17139200888709816, 0.18907415464725275, 0.20591623110250046, NaN], 4.251535435140605)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For any airfoil coordinate generation method (from FLOWFoil or otherwise), the coordinates must start at the trailing edge, and proceed clockwise around the airfoil.</p></div></div><h4 id="Generate-Meshes"><a class="docs-heading-anchor" href="#Generate-Meshes">Generate Meshes</a><a id="Generate-Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Meshes" title="Permalink"></a></h4><p>We&#39;ll next take that geometry and create a simple mesh object that holds the coordinates as well as pertinent information regarding the trailing edge.</p><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.generate_mesh" href="#FLOWFoil.generate_mesh"><code>FLOWFoil.generate_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_mesh(x, y; chordlength, wakelength)</code></pre><p>Create panels from input geometry coordinates.</p><p><strong>Arguments:</strong></p><ul><li><code>x::Vector{Float}</code> : x coordinates defining airfoil geometry.</li><li><code>y::Vector{Float}</code> : y coordinates defining airfoil geometry.</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>gaptolerance::Float</code> : Tolerance for how close, relative to the chord, the trailing edge nodes can be before being considered a sharp trailing edge. (default = 1e-10)</li></ul><p><strong>Returns</strong></p><ul><li><code>mesh::PlanarMesh</code> : Geometry mesh, including panel nodes and trailing edge condition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/geometry.jl#L12-L26">source</a></section><section><div><pre><code class="nohighlight hljs">generate_mesh(coordinates; kwargs)</code></pre><p>Identical to implementation with x and y separate, but here with x,y coordinates together in a single array [X Y].</p><p><strong>Arguments:</strong></p><ul><li><code>coordinates::Array{Float,2}</code> : array of both x and y coordinates (x first column, y second column).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/geometry.jl#L64-L71">source</a></section></article><pre><code class="language-julia hljs"># generate mesh object
meshes = [FLOWFoil.generate_mesh([x z])]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}}:
 PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}([[1.0 0.0], [0.9995248162243985 9.425534649137159e-5], [0.9980903569924046 0.0003694141342842627], [0.9956850819705431 0.0008126759922436631], [0.9923000441959984 0.0014094627436582348], [0.9879290886587452 0.0021435350004424163], [0.9825690388187502 0.002997136264856181], [0.9762198670587461 0.0039511638536683085], [0.9688848450699112 0.004985365312262039], [0.9605706702788714 0.006078558318575619]  …  [0.9640288022776758 0.008454232558185917], [0.9713428694626741 0.006661449557233686], [0.97788405787437 0.0050784196826802516], [0.9836266963174816 0.003709385941490379], [0.9885459283032532 0.00255686489165721], [0.9926178787951765 0.0016215635777949856], [0.995819832762403 0.0009023108156296526], [0.9981304243720296 0.00039600513565173713], [0.999529835269487 9.758165048200181e-5], [1.0 0.0]], 1.0, false, 0.0, 0.0, 0.0)</code></pre><h4 id="Define-Problem"><a class="docs-heading-anchor" href="#Define-Problem">Define Problem</a><a id="Define-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Problem" title="Permalink"></a></h4><p>We&#39;ll define a problem using the mesh array we just created, and indicate that we want to solve the inviscid problem by setting the viscous keyword argument to false. The problem object is very simple in the inviscid case, but carries more information about the freestream for the viscous problem (not yet implemented)</p><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.Problem" href="#FLOWFoil.Problem"><code>FLOWFoil.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Problem(meshes, angleofattack=0.0, reynolds=0.0, mach=0.0; viscous=true, verbose=false)</code></pre><p>Constructor for Problem Objects.</p><p><strong>Arguments:</strong></p><ul><li><code>meshes::Array{PlanarMesh or AxiSymMesh}</code> : Array of mesh objects</li><li><code>angleofattack::Float</code> : Angle of Attack (currently unused)</li><li><code>reynolds::Float</code> : Reynolds Number (currently unused)</li><li><code>mach::Float</code> : Mach Number (currently unused)</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>viscous::Bool</code> : Flag to solve viscous or inviscid only</li><li><code>axisymmetric::Bool</code> : Flag for axisymmetric solver.</li><li><code>verbose::Bool</code> : Flag to print out verbose statements</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/types.jl#L35-L50">source</a></section></article><pre><code class="language-julia hljs">## -- DEFINE PROBLEM
problem = FLOWFoil.Problem(meshes; viscous=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Problem{Vector{PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}}, Float64, Bool}(PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}[PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}([[1.0 0.0], [0.9995248162243985 9.425534649137159e-5], [0.9980903569924046 0.0003694141342842627], [0.9956850819705431 0.0008126759922436631], [0.9923000441959984 0.0014094627436582348], [0.9879290886587452 0.0021435350004424163], [0.9825690388187502 0.002997136264856181], [0.9762198670587461 0.0039511638536683085], [0.9688848450699112 0.004985365312262039], [0.9605706702788714 0.006078558318575619]  …  [0.9640288022776758 0.008454232558185917], [0.9713428694626741 0.006661449557233686], [0.97788405787437 0.0050784196826802516], [0.9836266963174816 0.003709385941490379], [0.9885459283032532 0.00255686489165721], [0.9926178787951765 0.0016215635777949856], [0.995819832762403 0.0009023108156296526], [0.9981304243720296 0.00039600513565173713], [0.999529835269487 9.758165048200181e-5], [1.0 0.0]], 1.0, false, 0.0, 0.0, 0.0)], 0.0, 0.0, 0.0, false, false, false)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even for single mesh objects, the meshes argument provided to the Problem constructor needs to be in an array.</p></div></div><h4 id="Solve-Problem"><a class="docs-heading-anchor" href="#Solve-Problem">Solve Problem</a><a id="Solve-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-Problem" title="Permalink"></a></h4><p>To solve the problem, we simply call the solve function, which will select the appropriate solver based on the viscous field in the problem. The solver returns a solution object, which nominally contains the vortex strengths and constant freestream strength on each node, as well as the mesh objects used in the solution, and some book keeping items from multi-element analyses.</p><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.solve" href="#FLOWFoil.solve"><code>FLOWFoil.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(problem)</code></pre><p>Solve problem defined by the input Problem object and return the solution in a Solution object.</p><p><strong>Arguments:</strong></p><ul><li><code>problem::Problem</code> : Problem to solve</li></ul><p><strong>Returns:</strong></p><ul><li><code>solution::{InviscidSolution or ViscousSolution}</code> : returns solution of type matching viscous flag in problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/solve.jl#L12-L22">source</a></section></article><pre><code class="language-julia hljs">## -- SOLVE PROBLEM
inviscid_solution = FLOWFoil.solve(problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">InviscidSolution{Vector{PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}}, Matrix{Float64}, Vector{Int64}, FLOWFoil.InviscidSystem{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}}(PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}[PlanarMesh{Float64, Bool, Vector{Matrix{Float64}}}([[1.0 0.0], [0.9995248162243985 9.425534649137159e-5], [0.9980903569924046 0.0003694141342842627], [0.9956850819705431 0.0008126759922436631], [0.9923000441959984 0.0014094627436582348], [0.9879290886587452 0.0021435350004424163], [0.9825690388187502 0.002997136264856181], [0.9762198670587461 0.0039511638536683085], [0.9688848450699112 0.004985365312262039], [0.9605706702788714 0.006078558318575619]  …  [0.9640288022776758 0.008454232558185917], [0.9713428694626741 0.006661449557233686], [0.97788405787437 0.0050784196826802516], [0.9836266963174816 0.003709385941490379], [0.9885459283032532 0.00255686489165721], [0.9926178787951765 0.0016215635777949856], [0.995819832762403 0.0009023108156296526], [0.9981304243720296 0.00039600513565173713], [0.999529835269487 9.758165048200181e-5], [1.0 0.0]], 1.0, false, 0.0, 0.0, 0.0)], [-0.8811651866554016 0.0868951250549049; -0.875062331265118 0.10529192390973569; … ; 0.8909822521174263 -0.06999996101103519; 0.8811651866554014 -0.08689512505490489], [-0.04342139086448289 -1.184765976821993], [160], FLOWFoil.InviscidSystem{Matrix{Float64}, Matrix{Float64}, Vector{Int64}}([-0.0003520642433712986 -0.0011270374434652142 … -0.0003493076181762214 -1.0; -0.00031351360350363413 -0.0012852774544373964 … -0.00031042564819477896 -1.0; … ; 1.0 -2.0 … -1.0 0.0; 1.0 0.0 … 1.0 0.0], [-0.0 1.0; -9.425534649137159e-5 0.9995248162243985; … ; 0.0 0.0; 0.0 0.0], [160]))</code></pre><h4 id="Post-Process"><a class="docs-heading-anchor" href="#Post-Process">Post Process</a><a id="Post-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Process" title="Permalink"></a></h4><p>With the solution calculated, we can post process by providing the angle of attack at which we want to know the various airfoil coefficients includeing lift and moment, as well as surface velocity and pressure distributions.</p><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.inviscid_polar" href="#FLOWFoil.inviscid_polar"><code>FLOWFoil.inviscid_polar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inviscid_polar(inviscid_solution, angleofattack; cascade=false)</code></pre><p>Generate Polar object for inviscid system at given angle of attack.</p><p><strong>Arguements:</strong></p><ul><li><code>inviscid_solution::InviscidSolution</code> : Inviscid Solution object</li><li><code>angleofattack::Float</code> : Angle of attack, in degrees</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/post_processes.jl#L11-L19">source</a></section></article><pre><code class="language-julia hljs">## -- POST PROCESS SOLUTION
# arbitrarily pick an angle of attack
alpha = 4.0
polar = FLOWFoil.inviscid_polar(inviscid_solution, alpha)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Polar{Float64, Vector{Float64}}(1.175169040255907, -0.0004132124675595819, 0.0, -0.0004132124675595819, 0.0, [-0.8729572150385314, -0.8655859300809572, -0.8588318014366699, -0.8523914641491955, -0.8459932734144301, -0.8397929678560406, -0.8338652092579504, -0.8282538003938533, -0.8229850937550629, -0.8180763501696818  …  0.9745262292635672, 0.9625093704525071, 0.950703914748512, 0.9391093886684451, 0.9277166952269676, 0.9164998164242215, 0.9054157126790287, 0.8942834560272289, 0.8839289136895235, 0.8729572150385313], [0.23794570071217125, 0.25076099764588433, 0.26240793684104435, 0.27342879184559066, 0.2842953813375373, 0.2947477711395431, 0.30466881278919467, 0.313995642133139, 0.3226955354569703, 0.3307510852930521  …  0.05029862847733313, 0.07357571179111855, 0.09616206648185399, 0.11807355611477943, 0.1393417333971536, 0.16002808649436828, 0.18022238723392658, 0.2002571002759953, 0.2186696755436589, 0.23794570071217147])</code></pre><p>Comparing our solution to the analytic solution we saved earlier, we see excellent agreement.</p><p><img src="../assets/joukowsky.jpg" alt/></p><hr/><h2 id="Multiple-Airfoil-Inviscid-Solution"><a class="docs-heading-anchor" href="#Multiple-Airfoil-Inviscid-Solution">Multiple Airfoil Inviscid Solution</a><a id="Multiple-Airfoil-Inviscid-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Airfoil-Inviscid-Solution" title="Permalink"></a></h2><p>For a multi-element airfoil system, the procedure is identical, except an array of meshes is used for the problem definition. For this case, we&#39;ll use data that comes from &quot;An Exact Test Case for the Plane Potential Flow About Two Adjacent Lifting Aerofoils&quot; by B. R. Williams.</p><pre><code class="language- hljs">using FLOWFoil
using PyPlot

## -- SET UP GEOMETRY
include(&quot;two_inviscid_airfoils.jl&quot;)

# set freestream to unity
vinf = 1.0
re = 1.0

# arbitrarily pick an angle of attack
alpha = 0.0

# generate mesh object
meshes = [FLOWFoil.generate_mesh([ximain etamain]); FLOWFoil.generate_mesh([xiflap etaflap])]

## -- DEFINE PROBLEM
problem = FLOWFoil.Problem(meshes; viscous=false)

## -- SOLVE PROBLEM
inviscid_solution = FLOWFoil.solve(problem)

## -- POST PROCESS SOLUTION
polar = FLOWFoil.inviscid_polar(inviscid_solution, alpha)
</code></pre><p>Again, we see excellent agreement with the analytical solution.</p><p><img src="../assets/two_inviscid_airfoils.jpg" alt/></p><hr/><h2 id="Axisymmetric-Body-of-Revolution"><a class="docs-heading-anchor" href="#Axisymmetric-Body-of-Revolution">Axisymmetric Body of Revolution</a><a id="Axisymmetric-Body-of-Revolution-1"></a><a class="docs-heading-anchor-permalink" href="#Axisymmetric-Body-of-Revolution" title="Permalink"></a></h2><p>FLOWFoil can also handle axisymmetric cases, including bodies of revolution which we domonstrate here.</p><pre><code class="language- hljs">using FLOWFoil
using PyPlot

include(&quot;../../test/data/bodyofrevolutioncoords.jl&quot;)
nothing #hide</code></pre><p>To let the problem and solver know that you are modeling an axisymmetric system, generate your meshes using the <code>generate_axisym_mesh</code> function. In addition, if you are modeling a body of revolution, that is, you have an open geometry at the axis of rotation, use the <code>bodyofrevolution</code> keyword argument.</p><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.generate_axisym_mesh" href="#FLOWFoil.generate_axisym_mesh"><code>FLOWFoil.generate_axisym_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_axisym_mesh(x, r; bodyofrevolution)</code></pre><p>Generate mesh for axisymmetric body.</p><p><strong>Arguments:</strong></p><ul><li><code>x::Array{Float}</code> : x-coordinates of geometry</li><li><code>r::Array{Float}</code> : r-coordinates of geometry</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>bodyofrevolution::Bool</code> : flag whether body is a body of revolution (default=true)</li></ul><p><strong>Returns:</strong></p><ul><li><code>mesh::FLOWFoil.AxiSymMesh</code> : axisymmetric mesh object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/geometry.jl#L506-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFoil.AxiSymMesh" href="#FLOWFoil.AxiSymMesh"><code>FLOWFoil.AxiSymMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AxiSymMesh{TP,TB}</code></pre><p>Axisymmetric Mesh Object</p><p><strong>Fields:</strong></p><ul><li><code>panels::FLOWFoil.AxiSymPanel</code> : panel objects describing surface geometry.</li><li><code>bodyofrevolution::Bool</code> : Flag as to whether or not the mesh represents a body of revolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFoil.jl/blob/cad94a9952fa72a1cfca18bd20c93a87797e4e38/src/types.jl#L324-L332">source</a></section></article><pre><code class="language- hljs">mesh = [FLOWFoil.generate_axisym_mesh(x, r; bodyofrevolution=true)]</code></pre><p>You will also need to set the <code>axisymmetric</code> keyword argument to true in your problem definition.</p><pre><code class="language- hljs">problem = FLOWFoil.Problem(mesh; axisymmetric=true, viscous=false)</code></pre><p>The solver function will know from the problem object which solver to use, and in this case will output a solution of type <code>InviscidSolution</code> as with the 2D cases.</p><pre><code class="language- hljs">solution = FLOWFoil.solve(problem)</code></pre><p>Finally, we can get the solution and plot the results</p><pre><code class="language- hljs">
# get surface velocity at control points
cpx = [mesh[1].panels[i].controlpoint[1] for i in 1:length(solution.panelgammas)]
surface_velocity = solution.panelgammas
nothing #hide</code></pre><p><img src="../assets/bodyofrevolution.jpg" alt/></p><hr/><h2 id="Axisymmetric-Annular-Airfoil-(Duct)"><a class="docs-heading-anchor" href="#Axisymmetric-Annular-Airfoil-(Duct)">Axisymmetric Annular Airfoil (Duct)</a><a id="Axisymmetric-Annular-Airfoil-(Duct)-1"></a><a class="docs-heading-anchor-permalink" href="#Axisymmetric-Annular-Airfoil-(Duct)" title="Permalink"></a></h2><p>If we define an airfoil shape in an axisymmetric scheme, we model an annular airfoil, or in other words, a duct.  To do so, we follow a similar procedure to bodies of revolution with the exception that we set <code>bodyofrevolution=false</code>.</p><pre><code class="language- hljs">using FLOWFoil
using PyPlot

include(&quot;../../test/data/naca_662-015.jl&quot;)

#Set bodyofrevolution to false
mesh = [FLOWFoil.generate_axisym_mesh(x, r, bodyofrevolution=false)]

problem = FLOWFoil.Problem(mesh; axisymmetric=true, viscous=false)

solution = FLOWFoil.solve(problem)

# get surface velocity at control points
cpx = [mesh[1].panels[i].controlpoint[1] for i in 1:length(solution.panelgammas)]

#note that the gamma values on the panels are equivalent to the surface velocity
cp = 1.0 .- solution.panelgammas .^ 2</code></pre><p>As above, we plot experimental results along with our calculated values.</p><p><img src="../assets/annular_airfoil.jpg" alt/></p><hr/><h2 id="Axisymmetric-Mutli-element-Systems"><a class="docs-heading-anchor" href="#Axisymmetric-Mutli-element-Systems">Axisymmetric Mutli-element Systems</a><a id="Axisymmetric-Mutli-element-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Axisymmetric-Mutli-element-Systems" title="Permalink"></a></h2><p>As an example of an multi-element axisymmetric system (such as that used for a ducted rotor), we will simply combine the two previous cases. We proceed in the same manner for 2D, planar multi-element systems in that we simply put the various mesh objects in an array when defining the problem object.</p><pre><code class="language-julia hljs">using FLOWFoil

# create annular airfoil mesh object
include(&quot;../../test/data/naca_662-015.jl&quot;)
duct = FLOWFoil.generate_axisym_mesh(x, r; bodyofrevolution=false)

# create body of revolution mesh object
include(&quot;../../test/data/bodyofrevolutioncoords.jl&quot;)
hub = FLOWFoil.generate_axisym_mesh(x, r; bodyofrevolution=true)

# define problem with both mesh objects
problem = FLOWFoil.Problem([duct; hub]; axisymmetric=true, viscous=false)

solution = FLOWFoil.solve(problem)

# Post Processing

# get surface velocity at control points
cpx = [(p -&gt; p.controlpoint[1]).(duct.panels); (p -&gt; p.controlpoint[1]).(hub.panels)]

#surface velocities
gammas = solution.panelgammas

# surface_velocity = FLOWFoil.axisymmetric_surface_pressure(solution)
cp = 1.0 .- gammas .^ 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">90×1 Matrix{Float64}:
  0.3086145205248624
  0.2718198487594534
  0.23808993589387573
  0.16461203408562675
  0.03825708516455095
 -0.118582951329677
 -0.31050012068625943
 -0.5328841429136506
 -0.6992337811898046
 -0.7511855960482854
  ⋮
  0.1077657620616187
  0.12782177913687431
  0.1474994565610388
  0.16734833515931646
  0.18819545541228366
  0.21157144570667086
  0.2422940166416243
  0.3053641162544136
  0.40073236906717336</code></pre><p>Plotting the geometry and the output velocities and pressures show expected behavior when combining these two cases.</p><p><img src="../assets/ducthubgeom.jpg" alt/></p><p><img src="../assets/multi_body_vs.jpg" alt/></p><p><img src="../assets/multi_body_cp.jpg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Intro</a><a class="docs-footer-nextpage" href="../examples/">Guided Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 14 October 2022 17:00">Friday 14 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
