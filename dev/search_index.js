var documenterSearchIndex = {"docs":
[{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Additional Types and Functions not already shown in other parts of the documentation.","category":"page"},{"location":"reference/#Public","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"reference/#Geometry-and-Meshing","page":"API Reference","title":"Geometry and Meshing","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.BodyMesh\nFLOWFoil.BodyMeshSystem\nFLOWFoil.position_meshes!","category":"page"},{"location":"reference/#FLOWFoil.BodyMesh","page":"API Reference","title":"FLOWFoil.BodyMesh","text":"BodyMesh{TF,TB}\n\nMesh for single body.\n\nFields:\n\nairfoil_nodes::Array{Array{Float,2}} : [x y] node (panel edge) locations for airfoil\nchord::Float : airfoil chord length\nblunt_te::Bool : boolean for whether or not the trailing edge is blunt or not.\ntrailing_edge_gap::Float : trailing edge gap distance\ntdp::Float : dot product of unit vectors of trailing edge bisection and gap vectors\ntxp::Float : pseudo-cross product of unit vectors of trailing edge bisection and gap vectors\n\nAssuptions:\n\nx and y coordinates start at the bottom trailing edge and proceed clockwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.BodyMeshSystem","page":"API Reference","title":"FLOWFoil.BodyMeshSystem","text":"BodyMeshSystem{TF}\n\nSystem of meshes to solve.\n\nFields:\n\nmeshes::Array{Mesh} : Array of mesh objects.\nscales::Vector{Float} : Airfoil scaling factors.\nangles::Vector{Float} : Airfoil angles of attack.\nlocations::Array{Array{TF}} : Array of leading edge locations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.position_meshes!","page":"API Reference","title":"FLOWFoil.position_meshes!","text":"position_meshes!(meshes, scales, angles, locations)\n\nTake in meshes and adjust scale, leading edge location, and angle of attack of the individual meshes in the system.  Updates mesh objects in place.\n\nArguments:\n\nmeshes::Array{BodyMesh} : Array of mesh objects.\nscales::Array{Float} : Array of numbers by which to scale respective meshes.\nlocations::Array{Array{Float}} : Array of [x y] positions of leading edges for respective meshes.\n\n\n\n\n\nposition_meshes!(meshsystem)\n\nIdentical to position_meshes!, but taking the inputs in as a BodyMeshSystem object.\n\nArguments:\n\nmeshsystem::BodyMeshSystem : Mesh system object to position.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Problems-and-Solutions","page":"API Reference","title":"Problems and Solutions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.Problem\nFLOWFoil.InviscidSolution","category":"page"},{"location":"reference/#FLOWFoil.Problem","page":"API Reference","title":"FLOWFoil.Problem","text":"Problem{TF,TB}\n\nProblem definition (geometry, operating point(s), and method selection) and output behavior.\n\nFields:\n\nmeshes::Array{BodyMesh} : Array of mesh objects\nmeshes::Array{BodyMesh} : Array of mesh objects\nangleofattack::Float : angle of attack to analyze.\nreynolds::Float : Reynolds number to analyze.\nmach::Float : Mach number to analyze.\nviscous::Bool : Flag to solve viscous or inviscid only\nverbose::Bool : Flag to print out verbose statements\ndebug::Bool : Flag to save the system structs, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.InviscidSolution","page":"API Reference","title":"FLOWFoil.InviscidSolution","text":"InviscidSolution{TM,TF,TD}\n\nFields:\n\nmesh::BodyMesh : BodyMesh object describing airfoil nodes etc.\npanelgammas::Array{Float,2} : gamma_0 and gamma_90 values at each airfoil node.\npsi0::Array{Float} : Psi_0 (constant stream function) 0 and 90 values.\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\ndebug::Debug : Debug object (or nothing) depending on debug flag in Problem object.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Post-Processing","page":"API Reference","title":"Post Processing","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.Polar\nFLOWFoil.calculate_stream_grid","category":"page"},{"location":"reference/#FLOWFoil.Polar","page":"API Reference","title":"FLOWFoil.Polar","text":"Polar{TF}\n\nFields:\n\nlift::Float : Lift Coefficient.\ndrag::Float : Total Drag Coefficient.\npdrag::Float : Pressure Drag Coefficient.\nidrag::Float : Induced Drag Coefficient.\nmoment::Float : Moment Coefficient.\nsurfacevelocity::Vector{Float} : surface velocity distribution\nsurfacepressure::Vector{Float} : surface pressure distribution\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.calculate_stream_grid","page":"API Reference","title":"FLOWFoil.calculate_stream_grid","text":"function calculate_stream_grid(problem, solution, xrange, zrange; Nx=100, Nz=100)\n\nCalculate stream function values across x- and z-ranges.\n\nArguments:\n\nproblem::Problem : Problem object associated with solution object.\nsolution::Solution : Solution object associated with problem.\nxrange::Array{Float} : minimum and maximum values of grid in x-direction, [xmin xmax]\nzrange::Array{Float} : minimum and maximum values of grid in z-direction, [zmin zmax]\n\nKeyword Arguments:\n\nNx::Int : Number of gridpoints in x-direction\nNz::Int : Number of gridpoints in z-direction\n\nReturns:\n\nxgrid::Array{Float} : Array of x-locations of gridpoints\nzgrid::Array{Float} : Array of z-locations of gridpoints\nstreamgrid::Array{Float,2} : Matrix of stream function values at gridpoints\n\n\n\n\n\n","category":"function"},{"location":"reference/#Convenience-Functions","page":"API Reference","title":"Convenience Functions","text":"","category":"section"},{"location":"reference/#Conformal-Mapped-Airfoils","page":"API Reference","title":"Conformal Mapped Airfoils","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.joukowsky\nFLOWFoil.joukowskyflow\nFLOWFoil.karman_trefftz","category":"page"},{"location":"reference/#FLOWFoil.joukowsky","page":"API Reference","title":"FLOWFoil.joukowsky","text":"joukowsky(center, radius; N, fortest=false, normalize=true, split=false)\n\nJoukowsky airfoil parameterization.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of center of circle relative to origin\nradius::Float : radius of circle\n\nKeyword Arguments:\n\nN::Int : Number of coordinates to use\nfortest::Bool : Flag to output non-coordinate paramters used in 'joukowskyflow()'\nnormalize::Bool : Flag whether to normalize to unit chord and translate the leading edge to zero.\nsplit::Bool : Flag wheter to split output into upper and lower surfaces.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.joukowskyflow","page":"API Reference","title":"FLOWFoil.joukowskyflow","text":"joukowskyflow(center, radius, alpha, vinf; N=360)\n\nCalculate the analytic surface velocities and pressures as well as lift coefficient for a joukowsky airfoil.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of circle center relative to origin\nradius::Float : Radius of circle\nalpha::Float : Angle of attack in degrees\nvinf::Float : Freestream velocity\n\nKeyword Arguments:\n\nN::Int : Number of coordinates to use\n\nReturns:\n\nvsurf::Array{Float} : Magnitude of surface velocities at the nodes\ncpsurf::Array{Float} : Surface pressures at the nodes\ncl::Float : Lift coefficient\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.karman_trefftz","page":"API Reference","title":"FLOWFoil.karman_trefftz","text":"karman_trefftz(beta, radius, wedge; N=360, normalize=true, split=false)\n\nKarman-Trefftz airfoil parameterization based on angle beta, raidus, and wedge angle.\n\nArguments:\n\nbeta::Float : angle, in radians indicating center of circle relative to origin\nradius::Float : radius of circle\nwedge::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments:\n\nN::Int : number of coordinates (for entire airfoil)\nnormalize::Bool` : Flag whether to normalize out put to unit chord and shift to have leading edge at zero.\nsplit::Bool` : Flag wheter to split into upper and lower halves.\n\nReturns: IF split == False:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nIF split == True:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\nkarman_trefftz(center=[-0.1 0.1], wedge=0.0; N=360, normalize=true, split=false)\n\nIdentical to karman_trefftz(beta, radius, wedge) but using center-based version.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of circle center relative to origin\nwedge::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments:\n\nN::Int : number of coordinates (for entire airfoil)\nnormalize::Bool : Flag whether to normalize out put to unit chord and shift to have leading edge at zero.\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns: IF split == False:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nIF split == True:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"reference/#NACA-4-Series","page":"API Reference","title":"NACA 4-Series","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.naca4","category":"page"},{"location":"reference/#FLOWFoil.naca4","page":"API Reference","title":"FLOWFoil.naca4","text":"naca4(c=2.0, p=4.0, t=12.0; N=161, x=nothing, blunt_TE=false, split=false)\n\nCompute x, y airfoil coordinates for N nodes, based on NACA 4-Series Parameterization.\n\nArguments:\n\nc::Float : Maximum camber value (percent of chord)\np::Float : Position along chord (in 10ths of chord) where maximum camber lies\nt::Float : Maximum thickness of airfoil in percent chord\n\nKeyword Arguments:\n\nN::Int : Total number of coordinates to use (should be odd)\nx::Array{Float} : x coordinates (cosine spaced coordinates used by default)\nblunt_TE::Bool : Flag whether trailing edge is blunt or not\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Private","page":"API Reference","title":"Private","text":"","category":"section"},{"location":"reference/#Inviscid-System-Construction","page":"API Reference","title":"Inviscid System Construction","text":"","category":"section"},{"location":"reference/#Setup","page":"API Reference","title":"Setup","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.size_system\nFLOWFoil.get_offset\nFLOWFoil.get_trailing_edge_info","category":"page"},{"location":"reference/#FLOWFoil.size_system","page":"API Reference","title":"FLOWFoil.size_system","text":"sizesystem(meshsystem)\n\nCount size of inviscid system matrix.\n\nArguments:\n\nmeshsystem::Array{BodyMesh} : The system for which to calculate the linear system size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_offset","page":"API Reference","title":"FLOWFoil.get_offset","text":"get_offset(Ns)\n\nGet the offset values for the mesh system to be used in the system matrix assembly.\n\nArguments:\n\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_trailing_edge_info","page":"API Reference","title":"FLOWFoil.get_trailing_edge_info","text":"get_trailing_edge_info(nodes)\n\nCalculate various items needed for trailing edge treatment.\n\nArguments:\n\nnodes::Array{Float,2} : Array of [x y] locations for the airfoil nodes.\n\nReturns:\n\ntdp::Float : dot product of TE bisection and TE gap unit vectors\ntxp::Float : \"cross product\" of TE bisection and TE gap unit vectors\ntrailing_edge_gap::Float : TE gap distance\n\n\n\n\n\n","category":"function"},{"location":"reference/#Panel-Geometry","page":"API Reference","title":"Panel Geometry","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.get_r\nFLOWFoil.get_d\nFLOWFoil.get_theta\nFLOWFoil.get_h\nFLOWFoil.get_a\nFLOWFoil.get_tangent\nFLOWFoil.get_normal\nFLOWFoil.get_distances\nFLOWFoil.get_orientation","category":"page"},{"location":"reference/#FLOWFoil.get_r","page":"API Reference","title":"FLOWFoil.get_r","text":"function get_r(node,point)\n\nCalculate the vector, mathbfr, and distance, r, from the node to the evaluation point\n\nArguments:\n\nnode::Array{Float} : [x y] position of node\npoint::Array{Float} : [x y] position of point.\n\nReturns\n\nr::Vector{Float} : vector from node to evaluation point\nrmag::Float : length of panel between node and evaluation point\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_d","page":"API Reference","title":"FLOWFoil.get_d","text":"get_d(node1, node2)\n\nCalculate panel length (between adjacent nodes).\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of first node\nnode2::Array{Float}(2) : [x y] location of second node\n\nReturns\n\nd::Vector{Float} : vector from node1 to node2\ndmag::Float : length of panel between node1 and node2\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_theta","page":"API Reference","title":"FLOWFoil.get_theta","text":"get_theta(h, a)\n\nGet angle (in radians) between panel and vector from node1 to evaluation point.\n\nArguments:\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\n\n\n\n\n\nget_theta(h, a, dmag)\n\nGet angle (in radians) between panel and vector from node2 to evaluation point.\n\nArguments:\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\ndmag::Float : Panel lentgh.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_h","page":"API Reference","title":"FLOWFoil.get_h","text":"get_h(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel normal direction.\n\nArguments:\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_a","page":"API Reference","title":"FLOWFoil.get_a","text":"get_a(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel tangent direction.\n\nArguments:\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_tangent","page":"API Reference","title":"FLOWFoil.get_tangent","text":"get_tangent(d, dmag)\n\nGet unit tangent to panel.\n\nArguments:\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_normal","page":"API Reference","title":"FLOWFoil.get_normal","text":"get_normal(d, dmag)\n\nGet unit normal to panel.\n\nArguments:\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_distances","page":"API Reference","title":"FLOWFoil.get_distances","text":"get_distances(node1, node2, point)\n\nGet vectors and magnitudes for panel and between nodes and validation points.\n\nArguments:\n\nnode1::Array{Float} : [x y] position of node1.\nnode2::Array{Float} : [x y] position of node2.\npoint::Array{Float} : [x y] position of evaluation point.\n\nReturns:\n\nr1::Vector{Float} : vector from node1 to evaluation point.\nr1mag::Float : distance from node1 to evaluation point.\nr2::Vector{Float} : vector from node2 to evaluation point.\nr2mag::Float : distance from node2 to evaluation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_orientation","page":"API Reference","title":"FLOWFoil.get_orientation","text":"get_orientation(node1, node2, point)\n\nGet angles between panel and evaluation point, ln of distances from nodes to evaluation point, and evaluation point position relative to panel.\n\nArguments:\n\nnode1::Array{Float} : [x y] position of node1.\nnode2::Array{Float} : [x y] position of node2.\npoint::Array{Float} : [x y] position of evaluation point.\n\nReturns:\n\ntheta1::Float : Angle between panel and evaluation point, centered at node1.\ntheta2::Float : Angle between panel and evaluation point, centered at node2.\nln1::Float : Natural log of distance from node1 to evaluation point.\nln2::Float : Natural log of distance from node2 to evaluation point.\nh::Float : Distance from panel to evaluation in panel normal direction.\na::Float : Distance from node1 to evaluation in panel tangent direction.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Singularity-Influences","page":"API Reference","title":"Singularity Influences","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.get_psibargamma\nFLOWFoil.get_psitildegamma\nFLOWFoil.get_vortex_influence\nFLOWFoil.get_psibarsigma\nFLOWFoil.get_psitildesigma\nFLOWFoil.get_source_influence","category":"page"},{"location":"reference/#FLOWFoil.get_psibargamma","page":"API Reference","title":"FLOWFoil.get_psibargamma","text":"get_psibargamma(theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  overlinePsi^gamma\n\nArguments:\n\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\nln1::Float : value of ln(rmag1), which may be that or 0.0, depening on evaluation point location\nln2::Float : value of ln(rmag2), which may be that or 0.0, depening on evaluation point location\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_psitildegamma","page":"API Reference","title":"FLOWFoil.get_psitildegamma","text":"get_psitildegamma(psibargamma, r1mag, r2mag, theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  widetildePsi^gamma\n\nArguments:\n\npsibargamma::Float : value of overlinePsi^gamma\nr1mag::Float : distance from node1 to evaluation point\nr2mag::Float : distance from node2 to evaluation point\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\nln1::Float : value of ln(rmag1), which may be that or 0.0, depening on evaluation point location\nln2::Float : value of ln(rmag2), which may be that or 0.0, depening on evaluation point location\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_vortex_influence","page":"API Reference","title":"FLOWFoil.get_vortex_influence","text":"get_vortex_influence(node1, node2, point)\n\nCalculate vortex influence coefficients on the evaluation point from the panel between node1 and node2.\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of node1\nnode2::Array{Float}(2) : [x y] location of node2\npoint::Array{Float}(2) : [x y] location of evaluation point\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_psibarsigma","page":"API Reference","title":"FLOWFoil.get_psibarsigma","text":"get_psibarsigma(theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  overlinePsi^sigma\n\nArguments:\n\ntheta1::Float : Angle between panel and evaluation point, centered at node1.\ntheta2::Float : Angle between panel and evaluation point, centered at node2.\nln1::Float : Natural log of distance from node1 to evaluation point.\nln2::Float : Natural log of distance from node2 to evaluation point.\nh::Float : Distance from panel to evaluation in panel normal direction.\na::Float : Distance from node1 to evaluation in panel tangent direction.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_psitildesigma","page":"API Reference","title":"FLOWFoil.get_psitildesigma","text":"get_psitildesigma(psibargamma, r1mag, r2mag, theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  widetildePsi^sigma\n\nArguments:\n\npsibargamma::Float : value of overlinePsi^sigma\nr1mag::Float : distance from node1 to evaluation point\nr2mag::Float : distance from node2 to evaluation point\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_source_influence","page":"API Reference","title":"FLOWFoil.get_source_influence","text":"get_source_influence(node1, node2, point)\n\nCalculate source influence coefficients on the evaluation point from the panel between node1 and node2.\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of node1\nnode2::Array{Float}(2) : [x y] location of node2\npoint::Array{Float}(2) : [x y] location of evaluation point\n\n\n\n\n\n","category":"function"},{"location":"reference/#Matrix-Assembly","page":"API Reference","title":"Matrix Assembly","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.InviscidSystem\nFLOWFoil.assemble_vortex_coefficients\nFLOWFoil.assemble_vortex_matrix\nFLOWFoil.assemble_boundary_conditions\nFLOWFoil.get_inviscid_system","category":"page"},{"location":"reference/#FLOWFoil.InviscidSystem","page":"API Reference","title":"FLOWFoil.InviscidSystem","text":"InviscidSystem{TF}\n\nFields:\n\nvcoeffmat::Array{Float,2} : Vortex Coefficient Matrix used in solution.\nbccoeffvec::Array{Float,2} : Boundary Coefficient Vector used in solution.\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.assemble_vortex_coefficients","page":"API Reference","title":"FLOWFoil.assemble_vortex_coefficients","text":"assemble_vortex_coefficients(meshi, meshj)\n\nAssemble matrix of vortex strength coefficients.\n\nThis function only assembles the NxM portion of the system influence coefficient matrix associated with the M-1 panels of meshj acting on the N nodes of meshi. It does not include the kutta condition or the influence of the constant stream function on the airfoil nodes.\n\nArguments:\n\nmeshi::BodyMesh : mesh being influenced.\nmeshj::BodyMesh : mesh doing the influencing.\ntrailing_edge_treatment::Bool : flag for whether to treat trailing edge or not (is meshi==meshj?)\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.assemble_vortex_matrix","page":"API Reference","title":"FLOWFoil.assemble_vortex_matrix","text":"assemble_vortex_matrix(meshes)\n\nAssemble vortex coefficient matrix with full N+n x N+n system, including Kutta condition, where n is the number of meshes (airfoils) in the system, and N is the total number of nodes between all the meshes.\n\nArguments:\n\nmeshes::Array{BodyMesh} : Mesh System for which to solve.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.assemble_boundary_conditions","page":"API Reference","title":"FLOWFoil.assemble_boundary_conditions","text":"assemble_boundary_conditions(meshes)\n\nAssemble boundary condition vector.\n\nArguments:\n\nmeshes::Array{BodyMesh} : mesh system for which to solve\n\nReturns\n\npsi_inf::Array{Float,2} : Boundary condition array.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_inviscid_system","page":"API Reference","title":"FLOWFoil.get_inviscid_system","text":"get_inviscid_system(meshes)\n\nCalculate, then gather the vortex and boundary condition matricies into an InviscidSystem object.\n\nArguments:\n\nmeshes::Array{BodyMesh} : BodyMesh for airfoil to analyze.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inviscid-System-Solving","page":"API Reference","title":"Inviscid System Solving","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.solve_inviscid\nFLOWFoil.solve_inviscid_system","category":"page"},{"location":"reference/#FLOWFoil.solve_inviscid","page":"API Reference","title":"FLOWFoil.solve_inviscid","text":"solve_inviscid(problem)\n\nSolves the inviscid problem.\n\nArguments:\n\nproblem::Problem : Problem to solve.  viscous field must be set to false.\n\nReturns:\n\nsolution::InviscidSolution\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.solve_inviscid_system","page":"API Reference","title":"FLOWFoil.solve_inviscid_system","text":"solve_inviscid_system(inviscidsystem, mesh; debug=false)\n\nSolve the InviscidSystem for the vortex and streamfunction strengths.\n\nOutputs the InviscidSolution object which contains the inviscidsystem in the debug object if debug is set to true.\n\nArguments:\n\ninviscidsystem::InviscidSystem : InviscidSystem to solve.\nmesh::BodyMesh : BodyMesh defining geometry (to put into solution object)\n\nKeyword Arguments:\n\ndebug::Bool = false : flag to indicate whether or not to output all the system details.\n\nReturns:\n\nsolution::InviscidSolution\n\n\n\n\n\n","category":"function"},{"location":"reference/#Post-Processing-2","page":"API Reference","title":"Post Processing","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.get_vortex_magnitudes\nFLOWFoil.get_stream_grid_value\nFLOWFoil.get_gamma_magnitudes","category":"page"},{"location":"reference/#FLOWFoil.get_vortex_magnitudes","page":"API Reference","title":"FLOWFoil.get_vortex_magnitudes","text":"get_vortex_magnitudes(inviscid_solution,angleofattack)\n\nCalculate the vortex strength magnitudes at the airfoil nodes for a given angle of attack.\n\nArguments:\n\ninviscid_solution::InviscidSolution : the inviscid solution from which to find the vortex magnitudes.\nangleofattack::Float : the angle of attack in degrees.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_stream_grid_value","page":"API Reference","title":"FLOWFoil.get_stream_grid_value","text":"get_stream_grid_value(gammas, nodes, point, vinf, alpha, blunt_te=false, txp=0.0, tdp=0.0)\n\nFor a given point, calculate the total stream function value induced by an airfoil.\n\nArguments:\n\ngammas::Array{Float} : Array of vortex strength magnitudes at each of the nodes.\nsigmas::Array{Float} : Array of source strength magnitudes at each of the nodes.\nnodes::Array{Array{Float}} : Array of node locations\npoint::Array{Float} : [x z] location of the point in question\nvinf::Float : Freestream magnitude\nalpah::Float : Angle of attack in degrees\nblunt_te::Bool : Flag whether airfoil has a blunt trailing edge or not\ntxp::Float : txp field from mesh object where nodes came from\ntdp::Float : tdp field from mesh object where nodes came from\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.get_gamma_magnitudes","page":"API Reference","title":"FLOWFoil.get_gamma_magnitudes","text":"get_gamma_magnitudes(panelgammas, angleofattack)\n\nCalculate vortex strength magnitudes for each of the nodes.\n\nArguements:\n\npanelgammas::Array{Float,2} : panelgammas field from solution object.\nangleofattack::Float : Angle of attack in degrees.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Convenience-Functions-2","page":"API Reference","title":"Convenience Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"FLOWFoil.cosinespacing\nFLOWFoil.split_upper_lower\nFLOWFoil.normalize_airfoil!\nFLOWFoil.thickness\nFLOWFoil.camber","category":"page"},{"location":"reference/#FLOWFoil.cosinespacing","page":"API Reference","title":"FLOWFoil.cosinespacing","text":"function cosinespacing(N=180)\n\nCalculate N cosine spaced points.\n\nArguments:\n\nN::Int : Number of points\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.split_upper_lower","page":"API Reference","title":"FLOWFoil.split_upper_lower","text":"split_upper_lower(x, z)\n\nSplit the upper and lower halves of the airfoil coordinates. Assumes odd number of coordinates (leading edge repeated).\n\nArguments:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nReturns:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.normalize_airfoil!","page":"API Reference","title":"FLOWFoil.normalize_airfoil!","text":"normalize_airfoil!(x, z)\n\nNormalize airfoil to unit chord and shift leading edge to zero. Adjusts coordinates in place.\n\nArguments:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.thickness","page":"API Reference","title":"FLOWFoil.thickness","text":"thickness(x, maxthick; blunt_TE=false)\n\nCompute thickness at a given chord-normalized x-position by NACA 4-series thickness equations.\n\nArguments:\n\nx::Float : x position along chordline\nmaxthick::Float : Maximum thickness value\n\nKeyword Arguments:\n\nblunt_TE::Bool : Flag whether trailing edge is blunt or not\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.camber","page":"API Reference","title":"FLOWFoil.camber","text":"camber(x, maxcamber, camberpose)\n\nCompute camber at a given chord-normalized x-position by NACA 4-series camber equations.\n\nArguments:\n\nx::Float : x position along chordline\nmaxcamber::Float64 : Maximum camber value\ncamberpose::Float64 : Position of maximum camber\n\n\n\n\n\n","category":"function"},{"location":"","page":"Intro","title":"Intro","text":"CurrentModule = FLOWFoil","category":"page"},{"location":"#FLOWFoil","page":"Intro","title":"FLOWFoil","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"FLOWFoil is a two dimensional potential flow solver (panel method) for airfoils and airfoil systems. The formulation used for FLOWFoil follows closely those of XFoil and mfoil (see also references below).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Currently, FLOWFoil only has inviscid capabilties for single and multi-element airfoils. Future additions will include visous capabilties for both single and multi-element airfoils as well.","category":"page"},{"location":"#References:","page":"Intro","title":"References:","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Drela, M., “XFOIL: An Analysis and Design System for Low Reynolds Number Airfoils,” 1989.\nFidkowski, K. J., “A Coupled Inviscid-Viscous Airfoil Analysis Solver, Revisited,” AIAA Journal, 2021.","category":"page"},{"location":"tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil is structured as follows:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The user generates a Problem.\nThe Problem is solved, generating a Solution.\nThe Solution is post-processed, generating a Polar.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are also some included convenience functions for geometry generation and manipulation.","category":"page"},{"location":"tutorial/#Single-Airfoil-Inviscid-Solution","page":"Quick Start","title":"Single Airfoil Inviscid Solution","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Let's first look at the simplest case, a single inviscid airfoil. We'll first set up the geometry, then define the problem, then solve the problem, then post process it, and finally plot some of the outputs.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFoil\nusing PyPlot","category":"page"},{"location":"tutorial/#Geometry-Definition","page":"Quick Start","title":"Geometry Definition","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For this example, we'll use one of the airfoil parameterization convenience functions to generate the x,z coordinates of an arbitrary Joukowsky airfoil. FLOWFoil includes several such convenience functions, which you can find more information on the API Reference page.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"## -- SET UP GEOMETRY\n\n# arbitrarily pick some joukowsky airfoil parameters\ncenter = [-0.1; 0.1]\nradius = 1.0\nnum_nodes = 160\n\n# get airfoil coordinates for joukowsky airfoil\nx, z = FLOWFoil.joukowsky(center, radius; N=num_nodes)\n\n# get analytic joukowsky solution for later, using alpha=4 and vinf = 1.0\nvj, cpj, clj = FLOWFoil.joukowskyflow(center, radius, 4.0, 1.0; N=num_nodes)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nFor any airfoil coordinate generation method (from FLOWFoil or otherwise), the coordinates must start at the trailing edge, and proceed clockwise around the airfoil.","category":"page"},{"location":"tutorial/#Generate-Meshes","page":"Quick Start","title":"Generate Meshes","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We'll next take that geometry and create a simple mesh object that holds the coordinates as well as pertinent information regarding the trailing edge.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil.generate_mesh","category":"page"},{"location":"tutorial/#FLOWFoil.generate_mesh","page":"Quick Start","title":"FLOWFoil.generate_mesh","text":"generate_mesh(x, y; chordlength, wakelength)\n\nCreate panels from input geometry coordinates.\n\nArguments:\n\nx::Vector{Float} : x coordinates defining airfoil geometry.\ny::Vector{Float} : y coordinates defining airfoil geometry.\n\nKeyword Arguments:\n\ngaptolerance::Float : Tolerance for how close, relative to the chord, the trailing edge nodes can be before being considered a sharp trailing edge. (default = 1e-10)\n\nReturns\n\nmesh::BodyMesh : Geometry mesh, including panel nodes and trailing edge condition.\n\n\n\n\n\ngenerate_mesh(coordinates; kwargs)\n\nIdentical to implementation with x and y separate, but here with x,y coordinates together in a single array [X Y].\n\nArguments:\n\ncoordinates::Array{Float,2} : array of both x and y coordinates (x first column, y second column).\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"# generate mesh object\nmeshes = [FLOWFoil.generate_mesh([x z])]","category":"page"},{"location":"tutorial/#Define-Problem","page":"Quick Start","title":"Define Problem","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We'll define a problem using the mesh array we just created, and indicate that we want to solve the inviscid problem by setting the viscous keyword argument to false. The problem object is very simple in the inviscid case, but carries more information about the freestream for the viscous problem (not yet implemented)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil.Problem(meshes, angleofattack=0.0, reynolds=0.0, mach=0.0; viscous=true, verbose=false, debug=false)","category":"page"},{"location":"tutorial/#FLOWFoil.Problem","page":"Quick Start","title":"FLOWFoil.Problem","text":"Problem(meshes, angleofattack=0.0, reynolds=0.0, mach=0.0; viscous=true, verbose=false, debug=false)\n\nConstructor for Problem Objects.\n\nArguments:\n\nmeshes::Array{BodyMesh} : Array of mesh objects\nangleofattack::Float : Angle of Attack (currently unused)\nreynolds::Float : Reynolds Number (currently unused)\nmach::Float : Mach Number (currently unused)\n\nKeyword Arguments:\n\nviscous::Bool : Flag to solve viscous or inviscid only\nverbose::Bool : Flag to print out verbose statements\ndebug::Bool : Flag to save the system structs, etc.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"## -- DEFINE PROBLEM\nproblem = FLOWFoil.Problem(meshes; viscous=false)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nEven for single mesh objects, the meshes argument provided to the Problem constructor needs to be in an array.","category":"page"},{"location":"tutorial/#Solve-Problem","page":"Quick Start","title":"Solve Problem","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"To solve the problem, we simply call the solve function, which will select the appropriate solver based on the viscous field in the problem. The solver returns a solution object, which nominally contains the vortex strengths and constant freestream strength on each node, as well as the mesh objects used in the solution, and some book keeping items from multi-element analyses.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil.solve","category":"page"},{"location":"tutorial/#FLOWFoil.solve","page":"Quick Start","title":"FLOWFoil.solve","text":"solve(problem)\n\nSolve problem defined by the input Problem object and return the solution in a Solution object.\n\nArguments:\n\nproblem::Problem : Problem to solve\n\nReturns:\n\nsolution::{InviscidSolution or ViscousSolution} : returns solution of type matching viscous flag in problem.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"## -- SOLVE PROBLEM\ninviscid_solution = FLOWFoil.solve(problem)","category":"page"},{"location":"tutorial/#Post-Process","page":"Quick Start","title":"Post Process","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"With the solution calculated, we can post process by providing the angle of attack at which we want to know the various airfoil coefficients includeing lift and moment, as well as surface velocity and pressure distributions.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil.inviscid_polar","category":"page"},{"location":"tutorial/#FLOWFoil.inviscid_polar","page":"Quick Start","title":"FLOWFoil.inviscid_polar","text":"inviscid_polar(inviscid_solution, angleofattack; cascade=false)\n\nGenerate Polar object for inviscid system at given angle of attack.\n\nArguements:\n\ninviscid_solution::InviscidSolution : Inviscid Solution object\nangleofattack::Float : Angle of attack, in degrees\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"## -- POST PROCESS SOLUTION\n# arbitrarily pick an angle of attack\nalpha = 4.0\npolar = FLOWFoil.inviscid_polar(inviscid_solution, alpha)","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Comparing our solution to the analytic solution we saved earlier, we see excellent agreement.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/#Multiple-Airfoil-Inviscid-Solution","page":"Quick Start","title":"Multiple Airfoil Inviscid Solution","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For a multi-element airfoil system, the procedure is identical, except an array of meshes is used for the problem definition. For this case, we'll use data that comes from \"An Exact Test Case for the Plane Potential Flow About Two Adjacent Lifting Aerofoils\" by B. R. Williams.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFoil\nusing PyPlot\n\n## -- SET UP GEOMETRY\ninclude(\"two_inviscid_airfoils.jl\")\n\n# set freestream to unity\nvinf = 1.0\nre = 1.0\n\n# arbitrarily pick an angle of attack\nalpha = 0.0\n\n# generate mesh object\nmeshes = [FLOWFoil.generate_mesh([ximain etamain]); FLOWFoil.generate_mesh([xiflap etaflap])]\n\n## -- DEFINE PROBLEM\nproblem = FLOWFoil.Problem(meshes; viscous=false)\n\n## -- SOLVE PROBLEM\ninviscid_solution = FLOWFoil.solve(problem)\n\n## -- POST PROCESS SOLUTION\npolar = FLOWFoil.inviscid_polar(inviscid_solution, alpha)\n","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Again, we see excellent agreement with the analytical solution.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"}]
}
