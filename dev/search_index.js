var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [FLOWFoil]","category":"page"},{"location":"reference/#FLOWFoil.BodyMesh","page":"API Reference","title":"FLOWFoil.BodyMesh","text":"BodyMesh{TF,TB}\n\nMesh for single body.\n\nFields:\n\nairfoil_nodes::Array{Array{Float,2}} : [x y] node (panel edge) locations for airfoil\nchord::Float : airfoil chord length\nblunt_te::Bool : boolean for whether or not the trailing edge is blunt or not.\ntrailing_edge_gap::Float : trailing edge gap distance\ntdp::Float : dot product of unit vectors of trailing edge bisection and gap vectors\ntxp::Float : pseudo-cross product of unit vectors of trailing edge bisection and gap vectors\n\nAssuptions:\n\nx and y coordinates start at the bottom trailing edge and proceed clockwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.BodyMeshSystem","page":"API Reference","title":"FLOWFoil.BodyMeshSystem","text":"BodyMeshSystem{TF}\n\nSystem of meshes to solve.\n\nFields:\n\nmeshes::Array{Mesh} : Array of mesh objects.\nscales::Vector{Float} : Airfoil scaling factors.\nangles::Vector{Float} : Airfoil angles of attack.\nlocations::Array{Array{TF}} : Array of leading edge locations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.InviscidSolution","page":"API Reference","title":"FLOWFoil.InviscidSolution","text":"InviscidSolution{TM,TF,TD}\n\nFields:\n\nmesh::BodyMesh : BodyMesh object describing airfoil nodes etc.\npanelgammas::Array{Float,2} : gamma_0 and gamma_90 values at each airfoil node.\npsi0::Array{Float} : Psi_0 (constant stream function) 0 and 90 values.\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\ndebug::Debug : Debug object (or nothing) depending on debug flag in Problem object.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.InviscidSystem","page":"API Reference","title":"FLOWFoil.InviscidSystem","text":"InviscidSystem{TF}\n\nFields:\n\nvcoeffmat::Array{Float,2} : Vortex Coefficient Matrix used in solution.\nbccoeffvec::Array{Float,2} : Boundary Coefficient Vector used in solution.\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.Polar","page":"API Reference","title":"FLOWFoil.Polar","text":"Polar{TF}\n\nFields:\n\nlift::Float : Lift Coefficient.\ndrag::Float : Total Drag Coefficient.\npdrag::Float : Pressure Drag Coefficient.\nidrag::Float : Induced Drag Coefficient.\nmoment::Float : Moment Coefficient.\nsurfacevelocity::Vector{Float} : surface velocity distribution\nsurfacepressure::Vector{Float} : surface pressure distribution\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.Problem","page":"API Reference","title":"FLOWFoil.Problem","text":"Problem{TF,TB}\n\nProblem definition (geometry, operating point(s), and method selection) and output behavior.\n\nFields:\n\ncoordinates::Array{Float} : x,y airfoil coordinates.\nangleofattack::Float : angle of attack to analyze.\nreynolds::Float : Reynolds number to analyze.\nmach::Float : Mach number to analyze.\nviscous::Bool : Flag to solve viscous or inviscid only\nverbose::Bool : Flag to print out verbose statements\ndebug::Bool : Flag to save the system structs, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FLOWFoil.assemble_boundary_conditions-Tuple{Any}","page":"API Reference","title":"FLOWFoil.assemble_boundary_conditions","text":"assemble_boundary_conditions(meshes)\n\nAssemble boundary condition vector.\n\nArguments:\n\nmeshes::Array{BodyMesh} : mesh system for which to solve\n\nReturns\n\npsi_inf::Array{Float,2} : Boundary condition array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.assemble_vortex_coefficients-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.assemble_vortex_coefficients","text":"assemble_vortex_coefficients(meshi, meshj)\n\nAssemble matrix of vortex strength coefficients.\n\nThis function only assembles the NxM portion of the system influence coefficient matrix associated with the M-1 panels of meshj acting on the N nodes of meshi. It does not include the kutta condition or the influence of the constant stream function on the airfoil nodes.\n\nArguments:\n\nmeshi::BodyMesh : mesh being influenced.\nmeshj::BodyMesh : mesh doing the influencing.\ntrailing_edge_treatment::Bool : flag for whether to treat trailing edge or not (is meshi==meshj?)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.assemble_vortex_matrix-Tuple{Any}","page":"API Reference","title":"FLOWFoil.assemble_vortex_matrix","text":"assemble_vortex_matrix(meshes)\n\nAssemble vortex coefficient matrix with full N+n x N+n system, including Kutta condition, where n is the number of meshes (airfoils) in the system, and N is the total number of nodes between all the meshes.\n\nArguments:\n\nmeshes::Array{BodyMesh} : Mesh System for which to solve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.calculate_stream_grid-NTuple{4, Any}","page":"API Reference","title":"FLOWFoil.calculate_stream_grid","text":"function calculate_stream_grid(problem, solution, xrange, zrange; Nx=100, Nz=100)\n\nCalculate stream function values across x- and z-ranges.\n\nArguments:\n\nproblem::Problem : Problem object associated with solution object.\nsolution::Solution : Solution object associated with problem.\nxrange::Array{Float} : minimum and maximum values of grid in x-direction, [xmin xmax]\nzrange::Array{Float} : minimum and maximum values of grid in z-direction, [zmin zmax]\n\nKeyword Arguments:\n\nNx::Int : Number of gridpoints in x-direction\nNz::Int : Number of gridpoints in z-direction\n\nReturns:\n\nxgrid::Array{Float} : Array of x-locations of gridpoints\nzgrid::Array{Float} : Array of z-locations of gridpoints\nstreamgrid::Array{Float,2} : Matrix of stream function values at gridpoints\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.camber-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.camber","text":"camber(x, maxcamber, camberpose)\n\nCompute camber at a given chord-normalized x-position by NACA 4-series camber equations.\n\nArguments:\n\nx::Float : x position along chordline\nmaxcamber::Float64 : Maximum camber value\ncamberpose::Float64 : Position of maximum camber\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.cosinespacing","page":"API Reference","title":"FLOWFoil.cosinespacing","text":"function cosinespacing(N=180)\n\nCalculate N cosine spaced points.\n\nArguments:\n\nN::Int : Number of points\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.generate_mesh-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.generate_mesh","text":"generatemesh(x, y; chordlength, wakelength)\n\nCreate panels from input geometry coordinates.\n\nArguments:\n\nx::Vector{Float} : x coordinates defining airfoil geometry.\ny::Vector{Float} : y coordinates defining airfoil geometry.\n\nKeyword Arguments:\n\ngaptolerance::Float : Tolerance for how close, relative to the chord, the trailing edge nodes can be before being considered a sharp trailing edge. (default = 1e-10)\n\nReturns\n\nmesh::BodyMesh : Geometry mesh, including panel nodes and trailing edge condition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.generate_mesh-Tuple{Any}","page":"API Reference","title":"FLOWFoil.generate_mesh","text":"generate_mesh(coordinates; kwargs)\n\nIdentical to implementation with x and y separate, but here with x,y coordinates together in a single array [X Y].\n\nArguments:\n\ncoordinates::Array{Float,2} : array of both x and y coordinates (x first column, y second column).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_a-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_a","text":"get_a(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel tangent direction.\n\nArguments:\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_d-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_d","text":"get_d(node1, node2)\n\nCalculate panel length (between adjacent nodes).\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of first node\nnode2::Array{Float}(2) : [x y] location of second node\n\nReturns\n\nd::Vector{Float} : vector from node1 to node2\ndmag::Float : length of panel between node1 and node2\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_distances-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_distances","text":"get_distances(node1, node2, point)\n\nGet vectors and magnitudes for panel and between nodes and validation points.\n\nArguments:\n\nnode1::Array{Float} : [x y] position of node1.\nnode2::Array{Float} : [x y] position of node2.\npoint::Array{Float} : [x y] position of evaluation point.\n\nReturns:\n\nr1::Vector{Float} : vector from node1 to evaluation point.\nr1mag::Float : distance from node1 to evaluation point.\nr2::Vector{Float} : vector from node2 to evaluation point.\nr2mag::Float : distance from node2 to evaluation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_gamma_magnitudes-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_gamma_magnitudes","text":"get_gamma_magnitudes(panelgammas, angleofattack)\n\nCalculate vortex strength magnitudes for each of the nodes.\n\nArguements:\n\npanelgammas::Array{Float,2} : panelgammas field from solution object.\nangleofattack::Float : Angle of attack in degrees.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_h-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_h","text":"get_h(r1, d, dmag)\n\nCalculate distance from panel to evalulation point in the panel normal direction.\n\nArguments:\n\nr1::Vector{Float} : vector from node1 to evalulation point.\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_inviscid_system-Tuple{Any}","page":"API Reference","title":"FLOWFoil.get_inviscid_system","text":"get_inviscid_system(meshes)\n\nCalculate, then gather the vortex and boundary condition matricies into an InviscidSystem object.\n\nArguments:\n\nmeshes::Array{BodyMesh} : BodyMesh for airfoil to analyze.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_normal-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_normal","text":"get_normal(d, dmag)\n\nGet unit normal to panel.\n\nArguments:\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_offset-Tuple{Any}","page":"API Reference","title":"FLOWFoil.get_offset","text":"get_offset(Ns)\n\nGet the offset values for the mesh system to be used in the system matrix assembly.\n\nArguments:\n\nNs::Array{Float} : Array of numbers of nodes for each airfoil in the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_orientation-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_orientation","text":"get_orientation(node1, node2, point)\n\nGet angles between panel and evaluation point, ln of distances from nodes to evaluation point, and evaluation point position relative to panel.\n\nArguments:\n\nnode1::Array{Float} : [x y] position of node1.\nnode2::Array{Float} : [x y] position of node2.\npoint::Array{Float} : [x y] position of evaluation point.\n\nReturns:\n\ntheta1::Float : Angle between panel and evaluation point, centered at node1.\ntheta2::Float : Angle between panel and evaluation point, centered at node2.\nln1::Float : Natural log of distance from node1 to evaluation point.\nln2::Float : Natural log of distance from node2 to evaluation point.\nh::Float : Distance from panel to evaluation in panel normal direction.\na::Float : Distance from node1 to evaluation in panel tangent direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_psibargamma-NTuple{7, Any}","page":"API Reference","title":"FLOWFoil.get_psibargamma","text":"get_psibargamma(theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  overbarPsi^gamma\n\nArguments:\n\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\nln1::Float : value of ln(rmag1), which may be that or 0.0, depening on evaluation point location\nln2::Float : value of ln(rmag2), which may be that or 0.0, depening on evaluation point location\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_psibarsigma-NTuple{7, Any}","page":"API Reference","title":"FLOWFoil.get_psibarsigma","text":"get_psibarsigma(theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  overbarPsi^sigma\n\nArguments:\n\ntheta1::Float : Angle between panel and evaluation point, centered at node1.\ntheta2::Float : Angle between panel and evaluation point, centered at node2.\nln1::Float : Natural log of distance from node1 to evaluation point.\nln2::Float : Natural log of distance from node2 to evaluation point.\nh::Float : Distance from panel to evaluation in panel normal direction.\na::Float : Distance from node1 to evaluation in panel tangent direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_psitildegamma-NTuple{10, Any}","page":"API Reference","title":"FLOWFoil.get_psitildegamma","text":"get_psitildegamma(psibargamma, r1mag, r2mag, theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  widetildePsi^gamma\n\nArguments:\n\npsibargamma::Float : value of overbarPsi^gamma\nr1mag::Float : distance from node1 to evaluation point\nr2mag::Float : distance from node2 to evaluation point\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\nln1::Float : value of ln(rmag1), which may be that or 0.0, depening on evaluation point location\nln2::Float : value of ln(rmag2), which may be that or 0.0, depening on evaluation point location\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_psitildesigma-NTuple{8, Any}","page":"API Reference","title":"FLOWFoil.get_psitildesigma","text":"get_psitildesigma(psibargamma, r1mag, r2mag, theta1, theta2, ln1, ln2, dmag, h, a)\n\nCalculate value of  widetildePsi^sigma\n\nArguments:\n\npsibargamma::Float : value of overbarPsi^gamma\nr1mag::Float : distance from node1 to evaluation point\nr2mag::Float : distance from node2 to evaluation point\ntheta1::Float : angle between panel and vector from node1 to evaluation point\ntheta2::Float : angle between panel and vector from node2 to evaluation point\ndmag::Float : panel length\nh::Float : height of right triangle with hypontenuse, r1, and base, a, colinear with panel.\na::Float : length of base of right triangle with height, h, and hypontenuse, r1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_r-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_r","text":"function get_r(node,point)\n\nCalculate the vector, mathbfr, and distance, r, from the node to the evaluation point\n\nArguments:\n\nnode::Array{Float} : [x y] position of node\npoint::Array{Float} : [x y] position of point.\n\nReturns\n\nr::Vector{Float} : vector from node to evaluation point\nrmag::Float : length of panel between node and evaluation point\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_source_influence-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_source_influence","text":"get_source_influence(node1, node2, point)\n\nCalculate source influence coefficients on the evaluation point from the panel between node1 and node2.\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of node1\nnode2::Array{Float}(2) : [x y] location of node2\npoint::Array{Float}(2) : [x y] location of evaluation point\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_stream_grid_value_inviscid-Tuple{}","page":"API Reference","title":"FLOWFoil.get_stream_grid_value_inviscid","text":"get_stream_grid_value_inviscid(gammas, nodes, point, vinf, alpha, blunt_te=false, txp=0.0, tdp=0.0)\n\nFor a given point, calculate the total stream function value induced by an airfoil.\n\nArguments:\n\ngammas::Array{Float} : Array of vortex strength magnitudes at each of the nodes.\nsigmas::Array{Float} : Array of source strength magnitudes at each of the nodes.\nnodes::Array{Array{Float}} : Array of node locations\npoint::Array{Float} : [x z] location of the point in question\nvinf::Float : Freestream magnitude\nalpah::Float : Angle of attack in degrees\nblunt_te::Bool : Flag whether airfoil has a blunt trailing edge or not\ntxp::Float : txp field from mesh object where nodes came from\ntdp::Float : tdp field from mesh object where nodes came from\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_tangent-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_tangent","text":"get_tangent(d, dmag)\n\nGet unit tangent to panel.\n\nArguments:\n\nd::Vector{Float} : vector from node1 to node2.\ndmag::Float : panel length\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_theta-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_theta","text":"get_theta(h, a, dmag)\n\nGet angle (in radians) between panel and vector from node2 to evaluation point.\n\nArguments:\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\ndmag::Float : Panel lentgh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_theta-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_theta","text":"get_theta(h, a)\n\nGet angle (in radians) between panel and vector from node1 to evaluation point.\n\nArguments:\n\nh::Float : Distance, normal to panel, between panel and evaluation point.\na::Float : Distance, tangent to panel, between node1 and evaluation point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_trailing_edge_info-Tuple{Any}","page":"API Reference","title":"FLOWFoil.get_trailing_edge_info","text":"get_trailing_edge_info(nodes)\n\nCalculate various items needed for trailing edge treatment.\n\nArguments:\n\nnodes::Array{Float,2} : Array of [x y] locations for the airfoil nodes.\n\nReturns:\n\ntdp::Float : dot product of TE bisection and TE gap unit vectors\ntxp::Float : \"cross product\" of TE bisection and TE gap unit vectors\ntrailing_edge_gap::Float : TE gap distance\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_vortex_influence-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.get_vortex_influence","text":"get_vortex_influence(node1, node2, point)\n\nCalculate vortex influence coefficients on the evaluation point from the panel between node1 and node2.\n\nArguments:\n\nnode1::Array{Float}(2) : [x y] location of node1\nnode2::Array{Float}(2) : [x y] location of node2\npoint::Array{Float}(2) : [x y] location of evaluation point\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.get_vortex_magnitudes-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.get_vortex_magnitudes","text":"get_vortex_magnitudes(inviscid_solution,angleofattack)\n\nCalculate the vortex strength magnitudes at the airfoil nodes for a given angle of attack.\n\nArguments:\n\ninviscid_solution::InviscidSolution : the inviscid solution from which to find the vortex magnitudes.\nangleofattack::Float : the angle of attack in degrees.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.inviscid_post-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.inviscid_post","text":"inviscid_post(inviscid_solution, angleofattack; cascade=false)\n\nGenerate Polar object for inviscid system at given angle of attack.\n\nArguements:\n\ninviscid_solution::InviscidSolution : Inviscid Solution object\nangleofattack::Float : Angle of attack, in degrees\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.joukowsky-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.joukowsky","text":"joukowsky(center, radius; N, fortest=false, normalize=true, split=false)\n\nJoukowsky airfoil parameterization.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of center of circle relative to origin\nradius::Float : radius of circle\n\nKeyword Arguments:\n\nN::Int : Number of coordinates to use\nfortest::Bool : Flag to output non-coordinate paramters used in 'joukowskyflow()'\nnormalize::Bool : Flag whether to normalize to unit chord and translate the leading edge to zero.\nsplit::Bool : Flag wheter to split output into upper and lower surfaces.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.joukowskyflow-NTuple{4, Any}","page":"API Reference","title":"FLOWFoil.joukowskyflow","text":"joukowskyflow(center, radius, alpha, vinf; N=360)\n\nCalculate the analytic surface velocities and pressures as well as lift coefficient for a joukowsky airfoil.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of circle center relative to origin\nradius::Float : Radius of circle\nalpha::Float : Angle of attack in degrees\nvinf::Float : Freestream velocity\n\nKeyword Arguments:\n\nN::Int : Number of coordinates to use\n\nReturns:\n\nvsurf::Array{Float} : Magnitude of surface velocities at the nodes\ncpsurf::Array{Float} : Surface pressures at the nodes\ncl::Float : Lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.karman_trefftz","page":"API Reference","title":"FLOWFoil.karman_trefftz","text":"karman_trefftz(center=[-0.1 0.1], wedge=0.0; N=360, normalize=true, split=false)\n\nIdentical to karman_trefftz(beta, radius, wedge) but using center-based version.\n\nArguments:\n\ncenter::Array{Float} : [x z] location of circle center relative to origin\nwedge::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments:\n\nN::Int : number of coordinates (for entire airfoil)\nnormalize::Bool : Flag whether to normalize out put to unit chord and shift to have leading edge at zero.\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\nReturns: IF split == False:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nIF split == True:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.karman_trefftz-Tuple{Any, Any, Any}","page":"API Reference","title":"FLOWFoil.karman_trefftz","text":"karman_trefftz(beta, radius, wedge; N=360, normalize=true, split=false)\n\nKarman-Trefftz airfoil parameterization based on angle beta, raidus, and wedge angle.\n\nArguments:\n\nbeta::Float : angle, in radians indicating center of circle relative to origin\nradius::Float : radius of circle\nwedge::Float : angle, in radians, of airfoil wedge angle\n\nKeyword Arguments:\n\nN::Int : number of coordinates (for entire airfoil)\nnormalize::Bool` : Flag whether to normalize out put to unit chord and shift to have leading edge at zero.\nsplit::Bool` : Flag wheter to split into upper and lower halves.\n\nReturns: IF split == False:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nIF split == True:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.naca4","page":"API Reference","title":"FLOWFoil.naca4","text":"naca4(c=2.0, p=4.0, t=12.0; N=161, x=nothing, blunt_TE=false, split=false)\n\nCompute x, y airfoil coordinates for N nodes, based on NACA 4-Series Parameterization.\n\nArguments:\n\nc::Float : Maximum camber value (percent of chord)\np::Float : Position along chord (in 10ths of chord) where maximum camber lies\nt::Float : Maximum thickness of airfoil in percent chord\n\nKeyword Arguments:\n\nN::Int : Total number of coordinates to use (should be odd)\nx::Array{Float} : x coordinates (cosine spaced coordinates used by default)\nblunt_TE::Bool : Flag whether trailing edge is blunt or not\nsplit::Bool : Flag wheter to split into upper and lower halves.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FLOWFoil.normalize_airfoil!-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.normalize_airfoil!","text":"normalize_airfoil!(x, z)\n\nNormalize airfoil to unit chord and shift leading edge to zero. Adjusts coordinates in place.\n\nArguments:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.position_meshes!-NTuple{4, Any}","page":"API Reference","title":"FLOWFoil.position_meshes!","text":"position_meshes!(meshes, scales, angles, locations)\n\nTake in meshes and adjust scale, leading edge location, and angle of attack of the individual meshes in the system.  Updates mesh objects in place.\n\nArguments:\n\nmeshes::Array{BodyMesh} : Array of mesh objects.\nscales::Array{Float} : Array of numbers by which to scale respective meshes.\nlocations::Array{Array{Float}} : Array of [x y] positions of leading edges for respective meshes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.position_meshes!-Tuple{Any}","page":"API Reference","title":"FLOWFoil.position_meshes!","text":"position_meshes!(meshsystem)\n\nIdentical to position_meshes!, but taking the inputs in as a BodyMeshSystem object.\n\nArguments:\n\nmeshsystem::BodyMeshSystem : Mesh system object to position.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.size_system-Tuple{Any}","page":"API Reference","title":"FLOWFoil.size_system","text":"sizesystem(meshsystem)\n\nCount size of inviscid system matrix.\n\nArguments:\n\nmeshsystem::Array{BodyMesh} : The system for which to calculate the linear system size.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.solve-Tuple{Any}","page":"API Reference","title":"FLOWFoil.solve","text":"solve(problem)\n\nSolve problem defined by the input Problem object and return the solution in a Solution object.\n\nArguments:\n\nproblem::Problem : Problem to solve\n\nReturns:\n\nsolution::{InviscidSolution or ViscousSolution} : returns solution of type matching viscous flag in problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.solve_inviscid-Tuple{Any}","page":"API Reference","title":"FLOWFoil.solve_inviscid","text":"solve_inviscid(problem)\n\nSolves the inviscid problem.\n\nArguments:\n\nproblem::Problem : Problem to solve.  viscous field must be set to false.\n\nReturns:\n\nsolution::InviscidSolution\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.solve_inviscid_system-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.solve_inviscid_system","text":"solve_inviscid_system(inviscidsystem, mesh; debug=false)\n\nSolve the InviscidSystem for the vortex and streamfunction strengths.\n\nOutputs the InviscidSolution object which contains the inviscidsystem in the debug object if debug is set to true.\n\nArguments:\n\ninviscidsystem::InviscidSystem : InviscidSystem to solve.\nmesh::BodyMesh : BodyMesh defining geometry (to put into solution object)\n\nKeyword Arguments:\n\ndebug::Bool = false : flag to indicate whether or not to output all the system details.\n\nReturns:\n\nsolution::InviscidSolution\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.split_upper_lower-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.split_upper_lower","text":"split_upper_lower(x, z)\n\nSplit the upper and lower halves of the airfoil coordinates. Assumes odd number of coordinates (leading edge repeated).\n\nArguments:\n\nx::Array{Float} : Array of x coordinates\nz::Array{Float} : Array of z coordinates\n\nReturns:\n\nxu::Array{Float} : Array of upper half of x coordinates\nxl::Array{Float} : Array of lower half of x coordinates\nzu::Array{Float} : Array of upper half of z coordinates\nzl::Array{Float} : Array of lower half of z coordinates\n\n\n\n\n\n","category":"method"},{"location":"reference/#FLOWFoil.thickness-Tuple{Any, Any}","page":"API Reference","title":"FLOWFoil.thickness","text":"thickness(x, maxthick; blunt_TE=false)\n\nCompute thickness at a given chord-normalized x-position by NACA 4-series thickness equations.\n\nArguments:\n\nx::Float : x position along chordline\nmaxthick::Float : Maximum thickness value\n\nKeyword Arguments:\n\nblunt_TE::Bool : Flag whether trailing edge is blunt or not\n\n\n\n\n\n","category":"method"},{"location":"","page":"Intro","title":"Intro","text":"CurrentModule = FLOWFoil","category":"page"},{"location":"#FLOWFoil","page":"Intro","title":"FLOWFoil","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"FLOWFoil is a two dimensional potential flow solver (panel method) for airfoils and airfoil systems. The formulation used for FLOWFoil follows closely those of XFoil and mfoil (see references below).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Currently, FLOWFoil only has inviscid capabilties for single and multi-element airfoils. Future additions will include visous capabilties for both single and multi-element airfoils as well.","category":"page"},{"location":"tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFoil is structured as follows:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The user generates a Problem.\nThe Problem is solved, generating a Solution.\nThe Solution is post-processed, generating a Polar.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are also some included convenience functions for geometry generation and manipulation.","category":"page"},{"location":"tutorial/#Single-Airfoil-Inviscid-Solution","page":"Quick Start","title":"Single Airfoil Inviscid Solution","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Let's first look at the simplest case, a single inviscid airfoil. We'll first set up the geometry, then defin the problem, then solve the problem, then post process it, and finally plot some of the outputs.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFoil\nusing PyPlot\n\n## -- SET UP GEOMETRY\n# arbitrarily pick some joukowsky airfoil parameters\ncenter = [-0.1; 0.1]\nradius = 1.0\nnum_nodes = 160\n\n# set freestream to unity\nvinf = 1.0\nre = 1.0\n\n# arbitrarily pick an angle of attack\nalpha = 4.0\n\n# get airfoil coordinates for joukowsky airfoil\nx, z = FLOWFoil.joukowsky(center, radius; N=num_nodes)\n\n# get analytic joukowsky solution for later\nvj, cpj, clj = FLOWFoil.joukowskyflow(center, radius, alpha, vinf; N=num_nodes)\n\n# generate mesh object\nmeshes = [FLOWFoil.generate_mesh([x z])]\n\n## -- DEFINE PROBLEM\nproblem = FLOWFoil.Problem(meshes, alpha, re; viscous=false)\n\n## -- SOLVE PROBLEM\ninviscid_solution = FLOWFoil.solve(problem)\n\n## -- POST PROCESS SOLUTION\npolar = FLOWFoil.inviscid_post(inviscid_solution, alpha)\n\n## -- PLOT\nfigure(1; figsize=(12, 3))\n\nsubplot(131)\nplot(x, z)\naxis(\"equal\")\naxis(\"off\")\n\nsubplot(132)\nxlabel(\"x\")\nylabel(L\"\\frac{V_T}{V_\\infty}\")\nplot(x, vj; label=\"Joukowsky\")\nplot(x, polar.surfacevelocity, \"--\"; linewidth=2, label=\"FLOWFoil\")\nlegend()\n\nsubplot(133)\nxlabel(\"x\")\nylabel(L\"c_p\")\nplot(x, cpj; label=\"Joukowsky\")\nplot(x, polar.surfacepressure, \"--\"; linewidth=2, label=\"FLOWFoil\")\nylim(1.0, -1.75)\nlegend()","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/#Multiple-Airfoil-Inviscid-Solution","page":"Quick Start","title":"Multiple Airfoil Inviscid Solution","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"For a multi-element airfoil system, the procedure is identical, except an array of meshes is used for the problem definition. For this case, we'll use data that comes from \"An Exact Test Case for the Plane Potential Flow About Two Adjacent Lifting Aerofoils\" by B. R. Williams.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFoil\nusing PyPlot\n\n## -- SET UP GEOMETRY\ninclude(\"two_inviscid_airfoils.jl\")\n\n# set freestream to unity\nvinf = 1.0\nre = 1.0\n\n# arbitrarily pick an angle of attack\nalpha = 0.0\n\n# generate mesh object\nmeshes = [FLOWFoil.generate_mesh([ximain etamain]); FLOWFoil.generate_mesh([xiflap etaflap])]\n\n## -- DEFINE PROBLEM\nproblem = FLOWFoil.Problem(meshes, alpha, re; viscous=false)\n\n## -- SOLVE PROBLEM\ninviscid_solution = FLOWFoil.solve(problem)\n\n## -- POST PROCESS SOLUTION\npolar = FLOWFoil.inviscid_post(inviscid_solution, alpha)\n\n## -- PLOT\nfigure(2; figsize=(9, 3))\nclf()\nsubplot(121)\nplot(ximain, etamain, label=\"Main Airfoil\")\nplot(xiflap, etaflap, label=\"Flap Airfoil\")\naxis(\"equal\")\naxis(\"off\")\n\nsubplot(122)\nxlabel(\"x\")\nylabel(L\"c_p\")\nplot(ximain, cpmain; label=\"Analytic\")\nplot(xiflap, cpflap)\nplot(ximain, polar.surfacepressure[1:length(ximain)], \".C0\"; linewidth=2, label=\"FLOWFoil\")\nplot(xiflap, polar.surfacepressure[length(ximain)+1:end], \".C1\"; linewidth=2)\nylim(maximum(polar.surfacepressure)*1.1, minimum(polar.surfacepressure)*1.1)\nlegend()","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"}]
}
