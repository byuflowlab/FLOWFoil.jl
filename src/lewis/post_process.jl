"""
    post_process(method::Lewis, panel_geometry, system_geometry, strengths, flow_angles; npanels=80)

Wrapper function for post-processing a single airfoil geometry using the Lewis method.
The `flow_angles` argument is included for interface compatibility but is unused.

# Arguments
- `method::Lewis`: Lewis method configuration object.
- `panel_geometry`: A single panel geometry (as a NamedTuple).
- `system_geometry`: Precomputed system geometry object used in the solver.
- `strengths`: Vector of strength values returned by the solver.
- `flow_angles`: Placeholder input; ignored in this function (included for API consistency).

# Keyword Arguments
- `npanels::Int=80`: Number of panels used in the geometry (for reference or optional reshaping).

# Returns
- `InviscidOutputs`: A structure containing:
  - `surface_velocity::Matrix`: Velocity on the surface panels.
  - `surface_pressure::Matrix`: Pressure coefficient distribution on panels.
  - `cl::Matrix`: Lift coefficient (always zero for axisymmetric bodies).
  - `cd::Matrix`: Drag coefficient (zero; not calculated here).
  - `cm::Matrix`: Moment coefficient (zero; not calculated here).
"""
function post_process(
    method::Lewis, panel_geometry, system_geometry, strengths, flow_angles; npanels=80
)
    return post_process(
        method, [panel_geometry], system_geometry, strengths, flow_angles; npanels=npanels
    )
end

"""
    post_process(method::Lewis, panel_geometry::AbstractVector, system_geometry, strengths, flow_angles; npanels=80)

Computes surface velocity and pressure coefficient distributions for multiple airfoil bodies using the Lewis method.

# Arguments
- `method::Lewis`: Lewis method configuration object.
- `panel_geometry::AbstractVector`: Vector of panel geometry NamedTuples, one for each body.
- `system_geometry`: System geometry used in the Lewis method solution.
- `strengths`: Vector of source/vortex strengths computed by the solver.
- `flow_angles`: Placeholder input; not used in the Lewis implementation (for compatibility only).

# Keyword Arguments
- `npanels::Int=80`: Number of panels (optional; not used internally).

# Returns
- `InviscidOutputs`: A structure containing:
  - `surface_velocity::Vector{Matrix}`: Velocity on surface panels per body.
  - `surface_pressure::Vector{Matrix}`: Pressure coefficient per panel per body.
  - `cl::Matrix`: Lift coefficient (not calculated; zero-filled).
  - `cd::Matrix`: Drag coefficient (not calculated; zero-filled).
  - `cm::Matrix`: Moment coefficient (not calculated; zero-filled).
"""
function post_process(
    method::Lewis,
    panel_geometry::AbstractVector,
    system_geometry,
    strengths,
    flow_angles;
    npanels=80,
)

    # - Rename for Convenience - #
    idx = system_geometry.panel_indices
    @show nbodies = system_geometry.nbodies

    # - Initialize Outputs - #
    TF = eltype(system_geometry.k2)

    vs = [zeros(idx[m][end] - idx[m][1] + 1, 1) for m in 1:nbodies]
    cp = [zeros(idx[m][end] - idx[m][1] + 1, 1) for m in 1:nbodies]
    cl = zeros(1, nbodies)
    cd = zeros(1, nbodies)
    cm = zeros(1, nbodies)

    for m in 1:nbodies
        # - Extract surface velocity - #
        #= Note that we here assume that we are using the subtractive method for the kutta conditions, requiring us to recover the strengths value for the last panel (trailing edge upper side).  We also assume here that the indexing starts at the lower side trailing edge and proceeds clockwise back to the upper side trailing edge.  Otherwise, not only will the solver not have worked, there will also be an indexing error here
        =#
        vs[m][:, 1] = [
            strengths[idx[m][1:(end - 1)]]
            -strengths[idx[m][1]]
        ]

        # - Calculate surface pressure - #
        cp[m][:, 1] = 1.0 .- (vs[m][:, 1]) .^ 2
    end

    if nbodies == 1
        return InviscidOutputs(vs[1], cp[1], cl, cd, cm)
    else
        return InviscidOutputs(vs, cp, cl, cd, cm)
    end
end

"""
    calculate_duct_thrust(method::Lewis, outputs, panel_geometry, system_geometry; Vinf=1.0, rho=1.225)

Computes the total thrust generated by a duct based on pressure forces on non-revolution body panels (i.e., annular ducts).

# Arguments
- `method::Lewis`: Lewis method configuration object.
- `outputs::InviscidOutputs`: Output from the solver/post-process step, including pressure coefficient.
- `panel_geometry::Vector{NamedTuple}`: Geometry data for each body.
- `system_geometry`: Precomputed system geometry, including body and panel indices.

# Keyword Arguments
- `Vinf::Float=1.0`: Freestream velocity.
- `rho::Float=1.225`: Freestream air density.

# Returns
- `thrust::Float`: Total duct thrust for the full annular domain. A negative value indicates drag.
"""
function calculate_duct_thrust(
    method::Lewis, outputs, panel_geometry, system_geometry; Vinf=1.0, rho=1.225
)

    # - Rename for Convenience - #
    idx = system_geometry.node_indices

    # Calculate dynamic pressure
    q = 0.5 * rho * Vinf^2

    # Initialize output
    TF = eltype(system_geometry.m)
    fx = zeros(TF, system_geometry.nbodies)

    # Loop through Bodies
    for m in 1:(system_geometry.nbodies)
        if !method.body_of_revolution[m]

            #dimensionalize pressure
            P = outputs.surface_pressure[idx[m]] .* q

            # add panel pressure in x-direction to total sectional force
            fx += sum(
                P .* panel_geometry[m].panel_length[:] .*
                panel_geometry[m].panel_normal[:, 1] .*
                panel_geometry[m].center_point[:, 2],
            )
        end
    end

    #return total duct thrust for whole annulus: -fx*2pi
    return fx * 2.0 * pi
end
